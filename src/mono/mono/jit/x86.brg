#include <glib.h>
#include <stdio.h>

#include <mono/metadata/blob.h>
#include <mono/metadata/metadata.h>
#include <mono/metadata/loader.h>
#include <mono/arch/x86/x86-codegen.h>

#define MBTREE_TYPE  MBTree

typedef struct _MBTree MBTree;
struct _MBTree {
	guint16 op;
	MBTree *left, *right;
	gpointer state;
	gpointer emit;

	guint is_jump:1;

	guint32 vaddr;
	guint32 addr;

	int reg;
	MonoTypeEnum type;

	union {
		int i;
		gpointer p;
	} data;
};

gboolean same_tree (MBTree *t1, MBTree *t2);

%%

#
# terminal definitions
#

# constatnts
%term CONST LDLOC LDARG STLOC BR RET RETV ARG CALL
%term ADD SUB MUL
%term BLT BEQ BGE 
#
# we start at stmt
#
%start stmt

#
# tree definitions
#

con: CONST

reg: LDLOC {
	switch (tree->type) {
	case MONO_TYPE_I4:  
		x86_mov_reg_membase (*code, tree->reg, X86_EBP,
				     - tree->data.i - 4, 4);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
}

reg: LDARG {
	switch (tree->type) {
	case MONO_TYPE_I:
	case MONO_TYPE_I4:
	case MONO_TYPE_CLASS:
	case MONO_TYPE_STRING:
	case MONO_TYPE_PTR:
		x86_mov_reg_membase (*code, tree->reg, X86_EBP,
				     tree->data.i + 8, 4);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
}

reg: MUL (reg, reg) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (*code, tree->reg, tree->left->reg, 4);
	x86_imul_reg_reg (*code, tree->reg, tree->right->reg);
} cost {
	MBCOND (tree->right->type == MONO_TYPE_I4);
	return 0;
}

reg: ADD (reg, con) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (*code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_imm (*code, X86_ADD, tree->reg, tree->right->data.i);
} cost {
	MBCOND (tree->right->type == MONO_TYPE_I4);
	return 0;
}

reg: ADD (reg, reg) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (*code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_reg (*code, X86_ADD, tree->reg, tree->right->reg);
} cost {
	MBCOND (tree->right->type == MONO_TYPE_I4);
	return 0;
}

reg: SUB (reg, con) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (*code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_imm (*code, X86_SUB, tree->reg, tree->right->data.i);
} cost {
	MBCOND (tree->right->type == MONO_TYPE_I4);
	return 0;
}

reg: SUB (reg, reg) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (*code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_reg (*code, X86_SUB, tree->reg, tree->right->reg);
} cost {
	MBCOND (tree->right->type == MONO_TYPE_I4);
	return 0;
}

stmt: STLOC (con) {
	x86_mov_membase_imm (*code, X86_EBP, - tree->data.i - 4,
			     tree->left->data.i, 4);
} cost {
	MBCOND (tree->left->type == MONO_TYPE_I4);
	return 0;
}

stmt: STLOC (reg) {	
	switch (tree->type) {
	case MONO_TYPE_I4:
		x86_mov_membase_reg (*code, X86_EBP, - tree->data.i - 4,
				     tree->left->reg, 4);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
}

stmt: BR {
	tree->is_jump = 1;
	x86_jump32 (*code, tree->data.i); 
}

stmt: BLT (reg, con) {
	tree->is_jump = 1;
	x86_alu_reg_imm (*code, X86_CMP, tree->left->reg, tree->right->data.i);
	x86_branch32 (*code, X86_CC_LT, tree->data.i - 6, TRUE); 
}

stmt: BEQ (reg, con) {
	tree->is_jump = 1;
	x86_alu_reg_imm (*code, X86_CMP, tree->left->reg, tree->right->data.i);
	x86_branch32 (*code, X86_CC_EQ, tree->data.i - 6 , TRUE);
}

stmt: BGE (reg, con) {
	tree->is_jump = 1;
	x86_alu_reg_imm (*code, X86_CMP, tree->left->reg, tree->right->data.i);
	x86_branch32 (*code, X86_CC_GE, tree->data.i - 6, TRUE);
}

stmt: RETV (reg) {
	tree->is_jump = 1;
	x86_jump32 (*code, tree->data.i - 5);      
	g_assert (tree->left->reg == X86_EAX); // return must be in EAX
}

stmt: RET {
	tree->is_jump = 1;
	x86_jump32 (*code, tree->data.i - 5); 
}

stmt: ARG (con) {
	x86_push_imm (*code, tree->left->data.i);
}

stmt: ARG (reg) {
	x86_push_reg (*code, tree->left->reg);
}

reg: CALL {
	switch (tree->type) {
	case MONO_TYPE_I4:
		x86_mov_reg_imm (*code, X86_EAX, tree->data.p);
		x86_call_membase (*code, X86_EAX, 
				  G_STRUCT_OFFSET (MonoMethod, addr));
		g_assert (tree->reg == X86_EAX);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
}

stmt: CALL {
	x86_mov_reg_imm (*code, X86_EAX, tree->data.p);
	x86_call_membase (*code, X86_EAX, G_STRUCT_OFFSET (MonoMethod, addr));
}

%% 

gboolean 
same_tree (MBTree *t1, MBTree *t2)
{
	if (t1 == t2)
		return TRUE;
	if (!t1 || !t2)
		return FALSE;

	if (t1->op == t2->op &&
	    t1->type == t2->type &&
	    t1->data.i == t2->data.i) {
		if (!same_tree (t1->left, t2->left))
			return FALSE;
		return same_tree (t1->right, t2->right);
	}
	return FALSE;
}

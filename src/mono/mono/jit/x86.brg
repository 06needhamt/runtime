#include <glib.h>
#include <stdio.h>

#include <mono/metadata/blob.h>
#include <mono/metadata/metadata.h>
#include <mono/metadata/loader.h>
#include <mono/arch/x86/x86-codegen.h>

#include "regset.h"

#define MBTREE_TYPE  MBTree
#define MBCGEN_TYPE  MBCodeGenStatus

typedef struct {
	guint8 *start;
	guint8 *code;
	gint32 locals_size;
	GPtrArray *forest;
	MonoRegSet *rs;
	guint32 epilog;
} MBCodeGenStatus;

typedef struct _MBTree MBTree;
struct _MBTree {
	guint16 op;
	MBTree *left, *right;
	gpointer state;
	gpointer emit;

	guint is_jump:1;
	guint last_instr:1;
	guint jump_target:1;

	gint32 cli_addr;   /* virtual cli address */
	gint32 addr;       /* address of emitted instruction */
	gint32 first_addr; /* first code address of a tree */ 

	int reg;
	MonoTypeEnum type;

	union {
		int i;
		gpointer p;
	} data;
};

gboolean same_tree (MBTree *t1, MBTree *t2);

%%

#
# terminal definitions
#

# constatnts
%term CONST_I4 CONST_R8
%term LDLOC LDARG STLOC BR RET RETV ARG CALL
%term ADD SUB MUL
%term BLT BEQ BGE BRTRUE
%term CONV_I4 CONV_I1 CONV_I2
#
# we start at stmt
#
%start stmt

#
# tree definitions
#

locaddr: LDLOC {
	/* nothing do do */;
}

locaddr: LDARG {
	tree->data.i = tree->data.i + 8;
}

# do nothing
reg: CONV_I4 (reg) 

reg: CONV_I1 (reg) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (s->code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_imm (s->code, X86_AND, tree->reg, 0xff);
}

reg: CONV_I2 (reg) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (s->code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_imm (s->code, X86_AND, tree->reg, 0xffff);
}

reg: LDLOC {
	switch (tree->type) {
	case MONO_TYPE_I1:
		x86_widen_membase (s->code, tree->reg, X86_EBP,
				   tree->data.i, TRUE, FALSE);
		break;
	case MONO_TYPE_U1:
	case MONO_TYPE_BOOLEAN:
		x86_widen_membase (s->code, tree->reg, X86_EBP,
				   tree->data.i, FALSE, FALSE);
		break;
	case MONO_TYPE_I2:
		x86_widen_membase (s->code, tree->reg, X86_EBP,
				   tree->data.i, TRUE, TRUE);
		break;
	case MONO_TYPE_U2:
	case MONO_TYPE_CHAR:
		x86_widen_membase (s->code, tree->reg, X86_EBP,
				   tree->data.i, FALSE, TRUE);
		break;

	case MONO_TYPE_I:
	case MONO_TYPE_I4:
	case MONO_TYPE_U4:
	case MONO_TYPE_CLASS:
	case MONO_TYPE_STRING:
	case MONO_TYPE_PTR:
		x86_mov_reg_membase (s->code, tree->reg, X86_EBP,
				     tree->data.i, 4);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
} cost {
	MBCOND (tree->type != MONO_TYPE_R4 &&
		tree->type != MONO_TYPE_R8 &&
		tree->type != MONO_TYPE_I8);

	return 1;
}

reg: LDARG {
	switch (tree->type) {
	case MONO_TYPE_I1:
	case MONO_TYPE_U1:
	case MONO_TYPE_BOOLEAN:
	case MONO_TYPE_I2:
	case MONO_TYPE_U2:
	case MONO_TYPE_CHAR:
	case MONO_TYPE_I:
	case MONO_TYPE_I4:
	case MONO_TYPE_U4:
	case MONO_TYPE_CLASS:
	case MONO_TYPE_STRING:
	case MONO_TYPE_PTR:
		x86_mov_reg_membase (s->code, tree->reg, X86_EBP,
				     tree->data.i + 8, 4);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
} cost {
	MBCOND (tree->type != MONO_TYPE_R4 &&
		tree->type != MONO_TYPE_R8 &&
		tree->type != MONO_TYPE_I8);

	return 1;
}


reg: MUL (reg, reg) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (s->code, tree->reg, tree->left->reg, 4);
	x86_imul_reg_reg (s->code, tree->reg, tree->right->reg);
}

reg: ADD (reg, CONST_I4) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (s->code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_imm (s->code, X86_ADD, tree->reg, tree->right->data.i);
}

reg: ADD (reg, reg) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (s->code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_reg (s->code, X86_ADD, tree->reg, tree->right->reg);
}

reg: SUB (reg, CONST_I4) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (s->code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_imm (s->code, X86_SUB, tree->reg, tree->right->data.i);
}

reg: SUB (reg, reg) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (s->code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_reg (s->code, X86_SUB, tree->reg, tree->right->reg);
}

stmt: STLOC (CONST_I4) {
	x86_mov_membase_imm (s->code, X86_EBP, tree->data.i,
			     tree->left->data.i, 4);
}

stmt: STLOC (reg) {	
	switch (tree->type) {
	case MONO_TYPE_I1:
	case MONO_TYPE_U1:
	case MONO_TYPE_BOOLEAN:
		x86_mov_membase_reg (s->code, X86_EBP, tree->data.i,
				     tree->left->reg, 1);
		break;
	case MONO_TYPE_I2:
	case MONO_TYPE_U2:
	case MONO_TYPE_CHAR:
		x86_mov_membase_reg (s->code, X86_EBP, tree->data.i,
				     tree->left->reg, 2);
		break;
	case MONO_TYPE_I:
	case MONO_TYPE_I4:
	case MONO_TYPE_U4:
	case MONO_TYPE_CLASS:
	case MONO_TYPE_STRING:
	case MONO_TYPE_PTR:
		x86_mov_membase_reg (s->code, X86_EBP, tree->data.i,
				     tree->left->reg, 4);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
}

stmt: BR {
	tree->is_jump = 1;
	x86_jump32 (s->code, tree->data.i - 5); 
}

stmt: BLT (reg, CONST_I4) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.i - offset, TRUE); 
}

stmt: BEQ (reg, CONST_I4) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.i - offset, TRUE);
}

stmt: BGE (reg, CONST_I4) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.i - offset, TRUE);
}

stmt: BRTRUE (reg) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg, 0);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.i - offset, TRUE);
}

stmt: RETV (reg) {

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, tree->data.i - 5);      
	}

	g_assert (tree->left->reg == X86_EAX); // return must be in EAX
}

stmt: RET {
	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, tree->data.i - 5);
	} 
}

stmt: ARG (CONST_I4) {
	x86_push_imm (s->code, tree->left->data.i);
}

stmt: ARG (reg) {
	x86_push_reg (s->code, tree->left->reg);
}

reg: CALL {
	switch (tree->type) {
	case MONO_TYPE_I1:
	case MONO_TYPE_U1:
	case MONO_TYPE_BOOLEAN:
	case MONO_TYPE_I2:
	case MONO_TYPE_U2:
	case MONO_TYPE_CHAR:
	case MONO_TYPE_I:
	case MONO_TYPE_I4:
	case MONO_TYPE_U4:
	case MONO_TYPE_CLASS:
	case MONO_TYPE_STRING:
	case MONO_TYPE_PTR:
		x86_mov_reg_imm (s->code, X86_EAX, tree->data.p);
		x86_call_membase (s->code, X86_EAX, 
				  G_STRUCT_OFFSET (MonoMethod, addr));
		g_assert (tree->reg == X86_EAX);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
} cost {
	MBCOND (tree->type != MONO_TYPE_R4 &&
		tree->type != MONO_TYPE_R8 &&
		tree->type != MONO_TYPE_I8);

	return 1;
}


stmt: CALL {
	x86_mov_reg_imm (s->code, X86_EAX, tree->data.p);
	x86_call_membase (s->code, X86_EAX, G_STRUCT_OFFSET (MonoMethod, addr));
}

#
# floating point 
# fixme: dont know how to assign registers?

freg: CONST_R8 {
	x86_fld (s->code, tree->data.p, TRUE);
}

freg: LDLOC {
	x86_fld_membase (s->code, X86_EBP, tree->data.i, 
			 tree->type == MONO_TYPE_R8);
} cost {
	MBCOND (tree->type == MONO_TYPE_R4 ||
		tree->type == MONO_TYPE_R8);
	return 0;
}

freg: LDARG {
	x86_fld_membase (s->code, X86_EBP, tree->data.i + 8, 
			 tree->type == MONO_TYPE_R8);
} cost {
	MBCOND (tree->type == MONO_TYPE_R4 ||
		tree->type == MONO_TYPE_R8);
	return 0;
}

freg: ADD (freg, freg) {
	x86_fp_op_reg (s->code, X86_FADD, 1, TRUE);
}

stmt: STLOC (freg) {
	g_assert (tree->type == MONO_TYPE_R4 ||
		  tree->type == MONO_TYPE_R8);

	x86_fst_membase (s->code, X86_EBP, tree->data.i, 
			 (tree->type == MONO_TYPE_R8), TRUE);	
}

stmt: ARG (freg) {
	x86_alu_reg_imm (s->code, X86_SUB, X86_ESP, 8);
	x86_fst_membase (s->code, X86_ESP, 0, TRUE, TRUE);
}

stmt: BEQ (freg, freg) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	x86_alu_reg_imm (s->code, X86_CMP, X86_EAX, 0x4000);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.i - offset, TRUE);
}

freg: CALL {
	x86_mov_reg_imm (s->code, X86_EAX, tree->data.p);
	x86_call_membase (s->code, X86_EAX, 
			  G_STRUCT_OFFSET (MonoMethod, addr));
} cost {
	MBCOND (tree->type == MONO_TYPE_R4 ||
		tree->type == MONO_TYPE_R8);
	return 0;
}

stmt: RETV (freg) {

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, tree->data.i - 5);      
	}

	//g_assert (tree->left->reg == X86_EAX); // return must be in EAX
}


#
# just some optimizazions
#

reg: ADD (locaddr, reg) {
	if (tree->reg != tree->right->reg)
		x86_mov_reg_reg (s->code, tree->reg, tree->right->reg, 4);
	x86_alu_reg_membase (s->code, X86_ADD, tree->reg, X86_EBP, 
			     tree->left->data.i);	
} cost {
	MBCOND (tree->left->type == MONO_TYPE_I4 ||
		tree->left->type == MONO_TYPE_U4);
	return 0;
}

reg: MUL (locaddr, reg) {
	if (tree->reg != tree->right->reg)
		x86_mov_reg_reg (s->code, tree->reg, tree->right->reg, 4);
	x86_imul_reg_membase (s->code, tree->reg, X86_EBP, tree->left->data.i);
} cost {
	MBCOND (tree->left->type == MONO_TYPE_I4 ||
		tree->left->type == MONO_TYPE_U4);
	return 0;
}

stmt: BEQ (locaddr, CONST_I4) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_membase_imm (s->code, X86_CMP, X86_EBP, tree->left->data.i, tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.i - offset, TRUE);
} cost {
	MBCOND (tree->left->type == MONO_TYPE_I4 ||
		tree->left->type == MONO_TYPE_U4);
	return 0;
}

stmt: BGE (locaddr, CONST_I4) {
	guint8 *start = s->code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_membase_imm (s->code, X86_CMP, X86_EBP, tree->left->data.i, 
			     tree->right->data.i);
	offset = 6 + s->code - start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.i - offset, TRUE);
} cost {
	MBCOND (tree->left->type == MONO_TYPE_I4 ||
		tree->left->type == MONO_TYPE_U4);
	return 0;
}

stmt: STLOC (ADD (LDLOC, CONST_I4)) {
	x86_alu_membase_imm (s->code, X86_ADD, X86_EBP, tree->data.i, 
			     tree->left->right->data.i);
} cost {
	MBCOND (tree->type == MONO_TYPE_I4 &&
		tree->left->left->type == MONO_TYPE_I4 &&
		tree->data.i == tree->left->left->data.i);
	return 0;
}


%% 

gboolean 
same_tree (MBTree *t1, MBTree *t2)
{
	if (t1 == t2)
		return TRUE;
	if (!t1 || !t2)
		return FALSE;

	if (t1->op == t2->op &&
	    t1->type == t2->type &&
	    t1->data.i == t2->data.i) {
		if (!same_tree (t1->left, t2->left))
			return FALSE;
		return same_tree (t1->right, t2->right);
	}
	return FALSE;
}

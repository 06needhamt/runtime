#include <glib.h>
#include <stdio.h>

#include <mono/metadata/blob.h>
#include <mono/metadata/metadata.h>
#include <mono/metadata/loader.h>
#include <mono/arch/x86/x86-codegen.h>

#define MBTREE_TYPE  MBTree

typedef struct _MBTree MBTree;
struct _MBTree {
	guint16 op;
	MBTree *left, *right;
	gpointer state;
	gpointer emit;

	guint is_jump:1;
	guint last_instr:1;
	guint jump_target:1;

	gint32 cli_addr;   /* virtual cli address */
	gint32 addr;       /* address of emitted instruction */
	gint32 first_addr; /* first code address of a tree */ 

	int reg;
	MonoTypeEnum type;

	union {
		int i;
		gpointer p;
	} data;
};

gboolean same_tree (MBTree *t1, MBTree *t2);

%%

#
# terminal definitions
#

# constatnts
%term CONST_I4 CONST_R8
%term LDLOC LDARG STLOC BR RET RETV ARG CALL
%term ADD SUB MUL
%term BLT BEQ BGE BRTRUE
%term CONV_I4 CONV_I1 CONV_I2
#
# we start at stmt
#
%start stmt

#
# tree definitions
#

locaddr: LDLOC {
	tree->data.i = - tree->data.i - 4;
}

locaddr: LDARG {
	tree->data.i = tree->data.i + 8;
}

# do nothing
reg: CONV_I4 (reg) 

reg: CONV_I1 (reg) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (*code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_imm (*code, X86_AND, tree->reg, 0xff);
}

reg: CONV_I2 (reg) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (*code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_imm (*code, X86_AND, tree->reg, 0xffff);
}

reg: LDLOC 1 {
	switch (tree->type) {
	case MONO_TYPE_I1:
		x86_widen_membase (*code, tree->reg, X86_EBP,
				   - tree->data.i - 4, TRUE, FALSE);
		break;
	case MONO_TYPE_U1:
	case MONO_TYPE_BOOLEAN:
		x86_widen_membase (*code, tree->reg, X86_EBP,
				   - tree->data.i - 4, FALSE, FALSE);
		break;
	case MONO_TYPE_I2:
		x86_widen_membase (*code, tree->reg, X86_EBP,
				   - tree->data.i - 4, TRUE, TRUE);
		break;
	case MONO_TYPE_U2:
	case MONO_TYPE_CHAR:
		x86_widen_membase (*code, tree->reg, X86_EBP,
				   - tree->data.i - 4, FALSE, TRUE);
		break;

	case MONO_TYPE_I:
	case MONO_TYPE_I4:
	case MONO_TYPE_U4:
	case MONO_TYPE_CLASS:
	case MONO_TYPE_STRING:
	case MONO_TYPE_PTR:
		x86_mov_reg_membase (*code, tree->reg, X86_EBP,
				     - tree->data.i - 4, 4);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
}

reg: LDARG 1 {
	switch (tree->type) {
	case MONO_TYPE_I1:
	case MONO_TYPE_U1:
	case MONO_TYPE_BOOLEAN:
	case MONO_TYPE_I2:
	case MONO_TYPE_U2:
	case MONO_TYPE_CHAR:
	case MONO_TYPE_I:
	case MONO_TYPE_I4:
	case MONO_TYPE_U4:
	case MONO_TYPE_CLASS:
	case MONO_TYPE_STRING:
	case MONO_TYPE_PTR:
		x86_mov_reg_membase (*code, tree->reg, X86_EBP,
				     tree->data.i + 8, 4);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
}

reg: MUL (reg, reg) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (*code, tree->reg, tree->left->reg, 4);
	x86_imul_reg_reg (*code, tree->reg, tree->right->reg);
}

reg: ADD (reg, CONST_I4) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (*code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_imm (*code, X86_ADD, tree->reg, tree->right->data.i);
}

reg: ADD (reg, reg) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (*code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_reg (*code, X86_ADD, tree->reg, tree->right->reg);
}

reg: SUB (reg, CONST_I4) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (*code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_imm (*code, X86_SUB, tree->reg, tree->right->data.i);
}

reg: SUB (reg, reg) {
	if (tree->reg != tree->left->reg)
		x86_mov_reg_reg (*code, tree->reg, tree->left->reg, 4);
	x86_alu_reg_reg (*code, X86_SUB, tree->reg, tree->right->reg);
}

stmt: STLOC (CONST_I4) {
	x86_mov_membase_imm (*code, X86_EBP, - tree->data.i - 4,
			     tree->left->data.i, 4);
}

stmt: STLOC (reg) {	
	switch (tree->type) {
	case MONO_TYPE_I1:
	case MONO_TYPE_U1:
	case MONO_TYPE_BOOLEAN:
		x86_mov_membase_reg (*code, X86_EBP, - tree->data.i - 4,
				     tree->left->reg, 1);
		break;
	case MONO_TYPE_I2:
	case MONO_TYPE_U2:
	case MONO_TYPE_CHAR:
		x86_mov_membase_reg (*code, X86_EBP, - tree->data.i - 4,
				     tree->left->reg, 2);
		break;
	case MONO_TYPE_I:
	case MONO_TYPE_I4:
	case MONO_TYPE_U4:
	case MONO_TYPE_CLASS:
	case MONO_TYPE_STRING:
	case MONO_TYPE_PTR:
		x86_mov_membase_reg (*code, X86_EBP, - tree->data.i - 4,
				     tree->left->reg, 4);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
}

stmt: BR {
	tree->is_jump = 1;
	x86_jump32 (*code, tree->data.i - 5); 
}

stmt: BLT (reg, CONST_I4) {
	guint8 *start = *code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (*code, X86_CMP, tree->left->reg, tree->right->data.i);
	offset = 6 + *code - start;
	x86_branch32 (*code, X86_CC_LT, tree->data.i - offset, TRUE); 
}

stmt: BEQ (reg, CONST_I4) {
	guint8 *start = *code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (*code, X86_CMP, tree->left->reg, tree->right->data.i);
	offset = 6 + *code - start;
	x86_branch32 (*code, X86_CC_EQ, tree->data.i - offset, TRUE);
}

stmt: BGE (reg, CONST_I4) {
	guint8 *start = *code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (*code, X86_CMP, tree->left->reg, tree->right->data.i);
	offset = 6 + *code - start;
	x86_branch32 (*code, X86_CC_GE, tree->data.i - offset, TRUE);
}

stmt: BRTRUE (reg) {
	guint8 *start = *code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (*code, X86_CMP, tree->left->reg, 0);
	offset = 6 + *code - start;
	x86_branch32 (*code, X86_CC_NE, tree->data.i - offset, TRUE);
}

stmt: RETV (reg) {

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (*code, tree->data.i - 5);      
	}

	g_assert (tree->left->reg == X86_EAX); // return must be in EAX
}

stmt: RET {
	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (*code, tree->data.i - 5);
	} 
}

stmt: ARG (CONST_I4) {
	x86_push_imm (*code, tree->left->data.i);
}

stmt: ARG (reg) {
	x86_push_reg (*code, tree->left->reg);
}

reg: CALL {
	switch (tree->type) {
	case MONO_TYPE_I1:
	case MONO_TYPE_U1:
	case MONO_TYPE_BOOLEAN:
	case MONO_TYPE_I2:
	case MONO_TYPE_U2:
	case MONO_TYPE_CHAR:
	case MONO_TYPE_I:
	case MONO_TYPE_I4:
	case MONO_TYPE_U4:
	case MONO_TYPE_CLASS:
	case MONO_TYPE_STRING:
	case MONO_TYPE_PTR:
		x86_mov_reg_imm (*code, X86_EAX, tree->data.p);
		x86_call_membase (*code, X86_EAX, 
				  G_STRUCT_OFFSET (MonoMethod, addr));
		g_assert (tree->reg == X86_EAX);
		break;
	default:
		g_warning ("unknown type %02x", tree->type);
		g_assert_not_reached ();
	}
}

stmt: CALL {
	x86_mov_reg_imm (*code, X86_EAX, tree->data.p);
	x86_call_membase (*code, X86_EAX, G_STRUCT_OFFSET (MonoMethod, addr));
}

#
# floating point 
#

freg: CONST_R8 {
	g_assert_not_reached ();
}

freg: ADD (freg, freg) {
	g_assert_not_reached ();
}

stmt: STLOC (freg) {
	g_assert_not_reached ();
}

stmt: ARG (freg) {
	g_assert_not_reached ();
	x86_push_reg (*code, tree->left->reg);
}



#
# just some optimizazions
#

reg: ADD (locaddr, reg) {
	if (tree->reg != tree->right->reg)
		x86_mov_reg_reg (*code, tree->reg, tree->right->reg, 4);
	x86_alu_reg_membase (*code, X86_ADD, tree->reg, X86_EBP, 
			     tree->left->data.i);	
} cost {
	MBCOND (tree->left->type == MONO_TYPE_I4 ||
		tree->left->type == MONO_TYPE_U4);
	return 0;
}

reg: MUL (locaddr, reg) {
	if (tree->reg != tree->right->reg)
		x86_mov_reg_reg (*code, tree->reg, tree->right->reg, 4);
	x86_imul_reg_membase (*code, tree->reg, X86_EBP, tree->left->data.i);
} cost {
	MBCOND (tree->left->type == MONO_TYPE_I4 ||
		tree->left->type == MONO_TYPE_U4);
	return 0;
}

stmt: BEQ (locaddr, CONST_I4) {
	guint8 *start = *code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_membase_imm (*code, X86_CMP, X86_EBP, tree->left->data.i, tree->right->data.i);
	offset = 6 + *code - start;
	x86_branch32 (*code, X86_CC_EQ, tree->data.i - offset, TRUE);
} cost {
	MBCOND (tree->left->type == MONO_TYPE_I4 ||
		tree->left->type == MONO_TYPE_U4);
	return 0;
}

stmt: BGE (locaddr, CONST_I4) {
	guint8 *start = *code;
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_membase_imm (*code, X86_CMP, X86_EBP, tree->left->data.i, tree->right->data.i);
	offset = 6 + *code - start;
	x86_branch32 (*code, X86_CC_GE, tree->data.i - offset, TRUE);
} cost {
	MBCOND (tree->left->type == MONO_TYPE_I4 ||
		tree->left->type == MONO_TYPE_U4);
	return 0;
}

stmt: STLOC (ADD (LDLOC, CONST_I4)) {
	x86_alu_membase_imm (*code, X86_ADD, X86_EBP, - tree->data.i - 4, tree->left->right->data.i);
} cost {
	MBCOND (tree->type == MONO_TYPE_I4 &&
		tree->left->left->type == MONO_TYPE_I4 &&
		tree->data.i == tree->left->left->data.i);
	return 0;
}


%% 

gboolean 
same_tree (MBTree *t1, MBTree *t2)
{
	if (t1 == t2)
		return TRUE;
	if (!t1 || !t2)
		return FALSE;

	if (t1->op == t2->op &&
	    t1->type == t2->type &&
	    t1->data.i == t2->data.i) {
		if (!same_tree (t1->left, t2->left))
			return FALSE;
		return same_tree (t1->right, t2->right);
	}
	return FALSE;
}

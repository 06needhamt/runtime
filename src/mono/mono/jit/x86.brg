/*
 * x86.brg: X86 code generator
 *
 * Author:
 *   Dietmar Maurer (dietmar@ximian.com)
 *
 * (C) 2001 Ximian, Inc.
 */

#include <glib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <sys/syscall.h>

#include <mono/metadata/blob.h>
#include <mono/metadata/metadata.h>
#include <mono/metadata/loader.h>
#include <mono/metadata/object.h>
#include <mono/metadata/tabledefs.h>
#include <mono/arch/x86/x86-codegen.h>

#include "regset.h"
#include "mempool.h"
#include "jit.h"

#define MBTREE_TYPE  MBTree
#define MBCGEN_TYPE  MonoFlowGraph
#define MBCOST_DATA  MonoFlowGraph
#define MBALLOC_STATE mono_mempool_alloc (data->mp, sizeof (MBState))

typedef enum {
	AMImmediate       = 0,  // ptr
	AMBase            = 1,  // V[REG]  
	AMIndex           = 2,  // V[REG*X] 
	AMBaseIndex       = 3,  // V[REG*X][REG] 
} X86AddMode;

typedef	struct {
	int           offset;
	X86AddMode    amode:2;
	unsigned int  shift:2;
	gint8         basereg;
	gint8         indexreg;
} X86AddressInfo;

struct _MBTree {
	guint16   op;
	MBTree   *left, *right;
	gpointer  state;
	gpointer  emit;

	gint32    addr;
	gint32    cli_addr;

	unsigned      is_jump:1;
	unsigned      last_instr:1;
	
	guint8    exclude_mask;

	gint8     reg1;
	gint8     reg2;
	gint8     reg3;
	
	MonoValueType svt;

	union {
		gint32 i;
		gint64 l;
		gpointer p;
		MonoBBlock *bb;
		MonoMethod *m;
		MethodCallInfo *ci;
		MonoClass *klass;
		X86AddressInfo ainfo;
	} data;
};

gint64  mono_llmult    (gint64 a, gint64 b);
gint64  mono_lldiv     (gint64 a, gint64 b);
gint64  mono_llrem     (gint64 a, gint64 b);
guint64 mono_lldiv_un  (guint64 a, guint64 b);
guint64 mono_llrem_un  (guint64 a, guint64 b);

gpointer 
get_throw_exception    (void);

gpointer
get_mono_object_isinst (void);

#define MB_OPT_LEVEL 1

#if MB_OPT_LEVEL == 0
#define MB_USE_OPT1(c) 65535
#define MB_USE_OPT2(c) 65535
#endif
#if MB_OPT_LEVEL == 1
#define MB_USE_OPT1(c) c
#define MB_USE_OPT2(c) 65535
#endif
#if MB_OPT_LEVEL >= 2
#define MB_USE_OPT1(c) c
#define MB_USE_OPT2(c) c
#endif

//#define DEBUG

#ifdef DEBUG
#define MEMCOPY debug_memcpy
void *MEMCOPY (void *dest, const void *src, size_t n);

#define PRINT_REG(text,reg) \
g_assert (reg >= 0); \
x86_push_reg (s->code, X86_EAX); \
x86_push_reg (s->code, X86_EDX); \
x86_push_reg (s->code, X86_ECX); \
x86_push_reg (s->code, reg); \
x86_push_imm (s->code, reg); \
x86_push_imm (s->code, text " %d %p\n"); \
x86_call_code (s->code, printf); \
x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 3*4); \
x86_pop_reg (s->code, X86_ECX); \
x86_pop_reg (s->code, X86_EDX); \
x86_pop_reg (s->code, X86_EAX); 
#else

#define MEMCOPY memcpy

#define PRINT_REG(x,y)

#endif

/* The call instruction for virtual functions must have a known
 * size (used by x86_magic_trampoline)
 */
#define x86_call_virtual(inst,basereg,disp)	               \
	do {	                                               \
		*(inst)++ = (unsigned char)0xff;               \
		x86_address_byte ((inst), 2, 2, (basereg));    \
		x86_imm_emit32 ((inst), (disp));	       \
	} while (0)

%%

#
# terminal definitions
#

# constatnts
%term CONST_I4 CONST_I8 CONST_R4 CONST_R8
%term LDIND_I1 LDIND_U1 LDIND_I2 LDIND_U2 LDIND_I4 LDIND_I8 LDIND_R4 LDIND_R8
%term LDIND_U4 LDIND_OBJ
%term STIND_I1 STIND_I2 STIND_I4 STIND_I8 STIND_R4 STIND_R8 STIND_OBJ
%term ADDR_L ADDR_G ARG_I4 ARG_I8 ARG_R4 ARG_R8 ARG_OBJ ARG_STRING CALL_I4 CALL_I8 CALL_R8 CALL_VOID
%term BREAK SWITCH BR RET_VOID RET RET_OBJ ENDFINALLY
%term ADD SUB MUL DIV DIV_UN REM REM_UN AND OR XOR SHL SHR SHR_UN NEG NOT
%term BLT BLT_UN BEQ BNE_UN BRTRUE BRFALSE BGE BGE_UN BLE BLE_UN BGT BGT_UN 
%term CEQ CLT
%term CONV_I4 CONV_I1 CONV_I2 CONV_I8 CONV_U8 CONV_R4 CONV_R8
%term INTF_ADDR VFUNC_ADDR NOP NEWARR NEWOBJ NEWSTRUCT CPOBJ POP INITOBJ
%term ISINST CASTCLASS UNBOX
%term CONV_OVF_I1 CONV_OVF_U1 CONV_OVF_I2 CONV_OVF_U2 CONV_OVF_U4 CONV_OVF_U8 CONV_OVF_I4
%term CONV_OVF_I2_UN CONV_OVF_I8_UN CONV_OVF_I1_UN 
%term EXCEPTION THROW RETHROW HANDLER 
%term LDLEN

#
# we start at stmt
#
%start stmt

#
# tree definitions
#

#
# x86 adressing mode
#

acon: CONST_I4 {
	tree->data.ainfo.offset = tree->data.i;
	tree->data.ainfo.amode = AMImmediate;
}

acon: ADDR_G {
	tree->data.ainfo.offset = tree->data.i;
	tree->data.ainfo.amode = AMImmediate;
}

acon: ADD (ADDR_G, CONST_I4) {
	tree->data.ainfo.offset = (unsigned)tree->left->data.p + tree->right->data.i;
	tree->data.ainfo.amode = AMImmediate;
}

base: acon

base: reg {
	tree->data.ainfo.offset = 0;
	tree->data.ainfo.basereg = tree->reg1;
	tree->data.ainfo.amode = AMBase;
}

base: ADD (reg, acon) {
	tree->data.ainfo.offset = tree->right->data.i;
	tree->data.ainfo.basereg = tree->left->reg1;
	tree->data.ainfo.amode = AMBase;
}

base: ADDR_L {
	tree->data.ainfo.offset = g_array_index (s->varinfo, MonoVarInfo, tree->data.i).offset;
	tree->data.ainfo.basereg = X86_EBP;
	tree->data.ainfo.amode = AMBase;
}

index: reg {
	tree->data.ainfo.offset = 0;
	tree->data.ainfo.indexreg = tree->reg1;
	tree->data.ainfo.shift = 0;
	tree->data.ainfo.amode = AMIndex;
}

index: SHL (reg, CONST_I4) {
	tree->data.ainfo.offset = 0;
	tree->data.ainfo.amode = AMIndex;
	tree->data.ainfo.indexreg = tree->left->reg1;
	tree->data.ainfo.shift = tree->right->data.i;
} cost {
	MBCOND (tree->right->data.i == 0 ||
		tree->right->data.i == 1 ||
		tree->right->data.i == 2 ||
		tree->right->data.i == 3);

	return 0;
}

index: MUL (reg, CONST_I4) {
	static int fast_log2 [] = { 1, 0, 1, -1, 2, -1, -1, -1, 3 };
  
	tree->data.ainfo.offset = 0;
	tree->data.ainfo.amode = AMIndex;
	tree->data.ainfo.indexreg = tree->left->reg1;
	tree->data.ainfo.shift = fast_log2 [tree->right->data.i];
} cost {
	MBCOND (tree->right->data.i == 1 ||
		tree->right->data.i == 2 ||
		tree->right->data.i == 4 ||
		tree->right->data.i == 8);

	return 0;
}

addr: base

addr: index

addr: ADD (index, base) {
	tree->data.ainfo.offset = tree->right->data.ainfo.offset;
	tree->data.ainfo.basereg = tree->right->data.ainfo.basereg;
	tree->data.ainfo.amode = tree->left->data.ainfo.amode | 
		tree->right->data.ainfo.amode;
	tree->data.ainfo.shift = tree->left->data.ainfo.shift;
	tree->data.ainfo.indexreg = tree->left->data.ainfo.indexreg;
}

# we pass exception in ECX to catch handler
reg: EXCEPTION {
	int offset = g_array_index (s->varinfo, MonoVarInfo, tree->data.i).offset;

	if (tree->reg1 != X86_ECX)
		x86_mov_reg_reg (s->code, tree->reg1, X86_ECX, 4);
	
	/* store it so that we can RETHROW it later */
	x86_mov_membase_reg (s->code, X86_EBP, offset, tree->reg1, 4);
}

stmt: THROW (reg) {
	if (tree->left->reg1 != X86_ECX)
		x86_mov_reg_reg (s->code, X86_ECX, tree->left->reg1, 4);

	x86_call_code (s->code, get_throw_exception ());
}

stmt: RETHROW {
	int offset = g_array_index (s->varinfo, MonoVarInfo, tree->data.i).offset;

	x86_mov_reg_membase (s->code, X86_ECX, X86_EBP, offset, 4);

	x86_call_code (s->code, get_throw_exception ());
}

stmt: HANDLER {
	gint32 addr = tree->data.bb->addr - tree->addr - 5;
	tree->is_jump = 1;    
	x86_call_imm (s->code, addr); 
}

stmt: ENDFINALLY {
	x86_ret (s->code);
}

stmt: STIND_I4 (addr, reg) {
	PRINT_REG ("STIND_I4", tree->right->reg1);

	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_mem_reg (s->code, tree->left->data.ainfo.offset, tree->right->reg1, 4);
		break;
		
	case AMBase:
		x86_mov_membase_reg (s->code, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, tree->right->reg1, 4);
		break;		
	case AMIndex:
		x86_mov_memindex_reg (s->code, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 4);
		break;		
	case AMBaseIndex:
		x86_mov_memindex_reg (s->code, tree->left->data.ainfo.basereg, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 4);
		break;		
	}
}

stmt: STIND_I1 (addr, reg) {
	PRINT_REG ("STIND_I1", tree->right->reg1);

	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_mem_reg (s->code, tree->left->data.ainfo.offset, tree->right->reg1, 1);
		break;
		
	case AMBase:
		x86_mov_membase_reg (s->code, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, tree->right->reg1, 1);
		break;		
	case AMIndex:
		x86_mov_memindex_reg (s->code, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 1);
		break;		
	case AMBaseIndex:
		x86_mov_memindex_reg (s->code, tree->left->data.ainfo.basereg, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 1);
		break;		
	}
}

stmt: STIND_I2 (addr, reg) {
	PRINT_REG ("STIND_I2", tree->right->reg1);

	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_mem_reg (s->code, tree->left->data.ainfo.offset, tree->right->reg1, 2);
		break;
		
	case AMBase:
		x86_mov_membase_reg (s->code, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, tree->right->reg1, 2);
		break;		
	case AMIndex:
		x86_mov_memindex_reg (s->code, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 2);
		break;		
	case AMBaseIndex:
		x86_mov_memindex_reg (s->code, tree->left->data.ainfo.basereg, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 2);
		break;		
	}
}

reg: LDIND_I4 (addr) {

	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_reg_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, 4);
		break;

	case AMBase:
		x86_mov_reg_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, 4);
		break;		
	case AMIndex:
		x86_mov_reg_memindex (s->code, tree->reg1, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, 4);
		break;		
	case AMBaseIndex:
		x86_mov_reg_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				      tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				      tree->left->data.ainfo.shift, 4);
		break;		
	}


	PRINT_REG ("LDIND_I4", tree->reg1);
}

reg: LDIND_I1 (addr) {
	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_widen_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, TRUE, FALSE);
		break;

	case AMBase:
		x86_widen_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				   tree->left->data.ainfo.offset, TRUE, FALSE);
		break;		
	case AMIndex:
		x86_widen_memindex (s->code, tree->reg1, X86_NOBASEREG, tree->left->data.ainfo.offset,
				    tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, TRUE, FALSE);
		break;		
	case AMBaseIndex:
		x86_widen_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				    tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				    tree->left->data.ainfo.shift, TRUE, FALSE);
		break;		
	}

	PRINT_REG ("LDIND_I1", tree->reg1);
}

reg: LDIND_U1 (addr) {
	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_widen_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, FALSE, FALSE);
		break;

	case AMBase:
		x86_widen_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				   tree->left->data.ainfo.offset, FALSE, FALSE);
		break;		
	case AMIndex:
		x86_widen_memindex (s->code, tree->reg1, X86_NOBASEREG, tree->left->data.ainfo.offset,
				    tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, FALSE, FALSE);
		break;		
	case AMBaseIndex:
		x86_widen_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				    tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				    tree->left->data.ainfo.shift, FALSE, FALSE);
		break;		
	}

	PRINT_REG ("LDIND_U1", tree->reg1);
}

reg: LDIND_I2 (addr) {
	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_widen_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, TRUE, TRUE);
		break;

	case AMBase:
		x86_widen_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				   tree->left->data.ainfo.offset, TRUE, TRUE);
		break;		
	case AMIndex:
		x86_widen_memindex (s->code, tree->reg1, X86_NOBASEREG, tree->left->data.ainfo.offset,
				    tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, TRUE, TRUE);
		break;		
	case AMBaseIndex:
		x86_widen_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				    tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				    tree->left->data.ainfo.shift, TRUE, TRUE);
		break;		
	}

	PRINT_REG ("LDIND_U2", tree->reg1);
}

reg: LDIND_U2 (addr) {
	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_widen_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, FALSE, TRUE);
		break;

	case AMBase:
		x86_widen_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				   tree->left->data.ainfo.offset, FALSE, TRUE);
		break;		
	case AMIndex:
		x86_widen_memindex (s->code, tree->reg1, X86_NOBASEREG, tree->left->data.ainfo.offset,
				    tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, FALSE, TRUE);
		break;		
	case AMBaseIndex:
		x86_widen_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				    tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				    tree->left->data.ainfo.shift, FALSE, TRUE);
		break;		
	}

	PRINT_REG ("LDIND_U2", tree->reg1);
}

reg: LDIND_U4 (addr) {
	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_reg_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, 4);
		break;

	case AMBase:
		x86_mov_reg_membase (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, 4);
		break;		
	case AMIndex:
		x86_mov_reg_memindex (s->code, tree->reg1, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift, 4);
		break;		
	case AMBaseIndex:
		x86_mov_reg_memindex (s->code, tree->reg1, tree->left->data.ainfo.basereg, 
				      tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				      tree->left->data.ainfo.shift, 4);
		break;		
	}

	PRINT_REG ("LDIND_U4", tree->reg1);
}

reg: ADDR_L 5 {
	int offset = g_array_index (s->varinfo, MonoVarInfo, tree->data.i).offset;  
	x86_lea_membase (s->code, tree->reg1, X86_EBP, offset);

	PRINT_REG ("ADDR_L",  tree->reg1);

}


reg: ADDR_G 5 {
	x86_mov_reg_imm (s->code, tree->reg1, tree->data.p);
}

reg: CONV_I1 (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_imm (s->code, X86_AND, tree->reg1, 0xff);
}

reg: CONV_I2 (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_imm (s->code, X86_AND, tree->reg1, 0xffff);
}

reg: CONST_I4 1 {
	x86_mov_reg_imm (s->code, tree->reg1, tree->data.i);
}

reg: CONV_I4 (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	PRINT_REG ("CONV_I4", tree->left->reg1);
} 

reg: CONV_OVF_U4 (reg) {
	x86_test_reg_imm (s->code, tree->left->reg1, 0x8000000);
	x86_branch8 (s->code, X86_CC_EQ, 10, TRUE);
	x86_mov_reg_imm (s->code, X86_ECX, get_exception_overflow ());
	x86_call_code (s->code, get_throw_exception ());
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
}

reg: CONV_OVF_I1 (reg) {
	/* probe value to be within -128 to 127 */
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, 127);
	x86_branch8 (s->code, X86_CC_LE, 10, TRUE);
	x86_mov_reg_imm (s->code, X86_ECX, get_exception_overflow ());
	x86_call_code (s->code, get_throw_exception ());
	
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, -128);
	x86_branch8 (s->code, X86_CC_LT, -17, TRUE);
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
}

reg: CONV_OVF_I1_UN (reg) {
	/* probe values between 0 to 128 */
	x86_test_reg_imm (s->code, tree->left->reg1, 0xffffff80);
	x86_branch8 (s->code, X86_CC_EQ, 10, TRUE);
	x86_mov_reg_imm (s->code, X86_ECX, get_exception_overflow ());
	x86_call_code (s->code, get_throw_exception ());
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);	
}

reg: CONV_OVF_U1 (reg) {
	/* probe value to be within 0 to 255 */
	x86_test_reg_imm (s->code, tree->left->reg1, 0xffffff00);
	x86_branch8 (s->code, X86_CC_EQ, 10, TRUE);
	x86_mov_reg_imm (s->code, X86_ECX, get_exception_overflow ());
	x86_call_code (s->code, get_throw_exception ());
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);	
}

reg: CONV_OVF_I2 (reg) {
	/* Probe value to be within -32768 and 32767 */

	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, 32767);
	x86_branch8 (s->code, X86_CC_LE, 10, TRUE);
	x86_mov_reg_imm (s->code, X86_ECX, get_exception_overflow ());
	x86_call_code (s->code, get_throw_exception ());

	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, -32768);
	x86_branch8 (s->code, X86_CC_LT, -17, TRUE);
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
}

reg: CONV_OVF_U2 (reg) {
	/* Probe value to be within 0 and 65535 */
	x86_test_reg_imm (s->code, tree->left->reg1, 0xffff0000);
	x86_branch8 (s->code, X86_CC_EQ, 10, TRUE);
	x86_mov_reg_imm (s->code, X86_ECX, get_exception_overflow ());
	x86_call_code (s->code, get_throw_exception ());
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);	
}

reg: CONV_OVF_I2_UN (reg) {
	/* Convert uint value into short, value within 0 and 32767 */
	x86_test_reg_imm (s->code, tree->left->reg1, 0xffff8000);
	x86_branch8 (s->code, X86_CC_EQ, 10, TRUE);
	x86_mov_reg_imm (s->code, X86_ECX, get_exception_overflow ());
	x86_call_code (s->code, get_throw_exception ());
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);	
}

reg: MUL (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_imul_reg_reg (s->code, tree->reg1, tree->right->reg1);
}

reg: DIV (reg, reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	x86_cdq (s->code);
	x86_div_reg (s->code, tree->right->reg1, TRUE);

	g_assert (tree->reg1 == X86_EAX &&
		  tree->reg2 == X86_EDX);
}

reg: DIV_UN (reg, reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	x86_cdq (s->code);
	x86_div_reg (s->code, tree->right->reg1, FALSE);

	g_assert (tree->reg1 == X86_EAX &&
		  tree->reg2 == X86_EDX);
}

reg: REM (reg, reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	x86_cdq (s->code);
	x86_div_reg (s->code, tree->right->reg1, TRUE);
	x86_mov_reg_reg (s->code, X86_EAX, X86_EDX, 4);

	g_assert (tree->reg1 == X86_EAX &&
		  tree->reg2 == X86_EDX);
}

reg: REM_UN (reg, reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	x86_cdq (s->code);
	x86_div_reg (s->code, tree->right->reg1, FALSE);
	x86_mov_reg_reg (s->code, X86_EAX, X86_EDX, 4);

	g_assert (tree->reg1 == X86_EAX &&
		  tree->reg2 == X86_EDX);
}

reg: ADD (reg, CONST_I4) "MB_USE_OPT1(0)" {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);

	if (tree->right->data.i == 1)
		x86_inc_reg (s->code, tree->reg1);
	else 
		x86_alu_reg_imm (s->code, X86_ADD, tree->reg1, tree->right->data.i);
}

reg: ADD (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_ADD, tree->reg1, tree->right->reg1);
}

reg: SUB (reg, CONST_I4) "MB_USE_OPT1(0)" {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);

	if (tree->right->data.i == 1)
		x86_dec_reg (s->code, tree->reg1);
	else
		x86_alu_reg_imm (s->code, X86_SUB, tree->reg1, tree->right->data.i);
}

reg: SUB (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_SUB, tree->reg1, tree->right->reg1);
}

reg: CEQ (reg, reg) {
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	x86_set_reg (s->code, X86_CC_EQ, tree->reg1, TRUE);
	x86_widen_reg (s->code, tree->reg1, tree->reg1, FALSE, FALSE);
}

reg: CLT (reg, reg) {
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	x86_set_reg (s->code, X86_CC_LT, tree->reg1, TRUE);
	x86_widen_reg (s->code, tree->reg1, tree->reg1, FALSE, FALSE);
}

reg: AND (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_AND, tree->reg1, tree->right->reg1);
}

reg: OR (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_OR, tree->reg1, tree->right->reg1);
}

reg: XOR (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_XOR, tree->reg1, tree->right->reg1);
}

reg: NEG (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	 x86_neg_reg (s->code, tree->reg1);
}

reg: NOT (reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	 x86_not_reg (s->code, tree->reg1);
}

reg: SHL (reg, CONST_I4) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_shift_reg_imm (s->code, X86_SHL, tree->reg1, tree->right->data.i);
}

reg: SHL (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->right->reg1 != X86_ECX)
		x86_mov_reg_reg (s->code, X86_ECX, tree->right->reg1, 4);
	x86_shift_reg (s->code, X86_SHL, tree->reg1);

	g_assert (tree->reg1 != X86_ECX &&
		  tree->left->reg1 != X86_ECX);
}

reg: SHR (reg, CONST_I4) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_shift_reg_imm (s->code, X86_SAR, tree->reg1, tree->right->data.i);
}

reg: SHR (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->right->reg1 != X86_ECX)
		x86_mov_reg_reg (s->code, X86_ECX, tree->right->reg1, 4);
	x86_shift_reg (s->code, X86_SAR, tree->reg1);

	g_assert (tree->reg1 != X86_ECX &&
		  tree->left->reg1 != X86_ECX);
}

reg: SHR_UN (reg, CONST_I4) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_shift_reg_imm (s->code, X86_SHR, tree->reg1, tree->right->data.i);
}

reg: SHR_UN (reg, reg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->right->reg1 != X86_ECX)
		x86_mov_reg_reg (s->code, X86_ECX, tree->right->reg1, 4);
	x86_shift_reg (s->code, X86_SHR, tree->reg1);

	g_assert (tree->reg1 != X86_ECX &&
		  tree->left->reg1 != X86_ECX);
}

# array support
reg: LDLEN (reg) {
	x86_mov_reg_membase (s->code, tree->reg1, tree->left->reg1,  
			     G_STRUCT_OFFSET (MonoArray, bounds), 4);
	x86_mov_reg_membase (s->code, tree->reg1, tree->reg1,  
			     G_STRUCT_OFFSET (MonoArrayBounds, length), 4);
}

#reg: LDELEMA (reg, reg) {
#	x86_imul_reg_reg_imm (s->code, tree->right->reg1, tree->right->reg1, tree->data.i);
#	x86_alu_reg_reg (s->code, X86_ADD, tree->reg1, tree->right->reg1);
#	x86_alu_reg_imm (s->code, X86_ADD, tree->reg1, G_STRUCT_OFFSET (MonoArray, vector));
#}

reg: NEWARR (reg) {
	if (tree->reg1 != X86_EAX)
		x86_push_reg (s->code, X86_EAX);
	x86_push_reg (s->code, X86_ECX);
	x86_push_reg (s->code, X86_EDX);

	x86_push_reg (s->code, tree->left->reg1);
	x86_push_imm (s->code, tree->data.p);
	x86_call_code (s->code, mono_array_new);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, sizeof (gpointer) + 4);

	x86_pop_reg (s->code, X86_EDX);
	x86_pop_reg (s->code, X86_ECX);
	if (tree->reg1 != X86_EAX) {
		x86_mov_reg_reg (s->code, tree->reg1, X86_EAX, 4);
		x86_pop_reg (s->code, X86_EAX);
	}
}

reg: NEWOBJ {
	if (tree->reg1 != X86_EAX)
		x86_push_reg (s->code, X86_EAX);
	x86_push_reg (s->code, X86_ECX);
	x86_push_reg (s->code, X86_EDX);

	x86_push_imm (s->code, tree->data.klass);
	x86_call_code (s->code, mono_object_new);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, sizeof (gpointer));

	x86_pop_reg (s->code, X86_EDX);
	x86_pop_reg (s->code, X86_ECX);
	if (tree->reg1 != X86_EAX) {
		x86_mov_reg_reg (s->code, tree->reg1, X86_EAX, 4);
		x86_pop_reg (s->code, X86_EAX);
	}
}

reg: NEWSTRUCT {
     	int size = tree->data.i;	
	int sa;
	
	g_assert (size > 0);

	sa = size + 3;
	sa &= ~3;

	x86_alu_reg_imm (s->code, X86_SUB, X86_ESP, sa);
	x86_mov_reg_reg (s->code, tree->reg1, X86_ESP, 4);
}

reg: UNBOX (reg) {
	guint8 *start = s->code, *l1, *l2, *l3, *le;
	int i;

	tree->is_jump = TRUE;
	l1 = l2 = l3 = le = NULL;

	for (i = 0; i < 2; i++) {
		s->code = start;

		if (tree->reg1 != tree->left->reg1)
			x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);

		x86_alu_reg_imm (s->code, X86_CMP, tree->reg1, 0);
		x86_branch8 (s->code, X86_CC_NE, l2 - l1, FALSE);
		l1 = s->code;
		x86_mov_reg_imm (s->code, X86_ECX, get_exception_null_reference ());
		x86_call_code (s->code, get_throw_exception ());
		l2 = s->code;
		x86_alu_membase_imm (s->code, X86_CMP, tree->reg1, 0, ((int)(tree->data.klass)));
		x86_branch8 (s->code, X86_CC_EQ, le - l3, FALSE);
		l3 = s->code;
		x86_mov_reg_imm (s->code, X86_ECX, get_exception_invalid_cast ());
		x86_call_code (s->code, get_throw_exception ());
		le = s->code;
		x86_alu_reg_imm (s->code, X86_ADD, tree->reg1, sizeof (MonoObject));
	}
}

reg: CASTCLASS (reg) {
	guint8 *start = s->code, *l1, *l2, *l3, *l4, *le;
	int i;

	tree->is_jump = TRUE;
	l1 = l2 = l3 = l4 = le = NULL;

	for (i = 0; i < 2; i++) {
		s->code = start;

		if (tree->reg1 != X86_EAX)
			x86_push_reg (s->code, X86_EAX);

		x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, 0);
		x86_branch8 (s->code, X86_CC_EQ, le - l2, FALSE);
		l2 = s->code;
		x86_push_reg (s->code, X86_ECX);
		x86_push_reg (s->code, X86_EDX);

		x86_push_imm (s->code, tree->data.klass);
		x86_push_reg (s->code, tree->left->reg1);
		x86_call_code (s->code, mono_object_isinst);
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 8);
		x86_pop_reg (s->code, X86_EDX);
		x86_pop_reg (s->code, X86_ECX);

		x86_alu_reg_imm (s->code, X86_CMP, X86_EAX, 0);
		x86_branch8 (s->code, X86_CC_NE, le - l3, FALSE);
		l3 = s->code;

		x86_mov_reg_imm (s->code, X86_ECX, get_exception_invalid_cast ());
		x86_call_code (s->code, get_throw_exception ());

		le = s->code;

	}
}

reg: ISINST (reg) {
	if (tree->reg1 != X86_EAX)
		x86_push_reg (s->code, X86_EAX);
	x86_push_reg (s->code, X86_ECX);
	x86_push_reg (s->code, X86_EDX);

	x86_push_imm (s->code, tree->data.klass);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_object_isinst);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 8);

	x86_pop_reg (s->code, X86_EDX);
	x86_pop_reg (s->code, X86_ECX);
	if (tree->reg1 != X86_EAX) {
		x86_mov_reg_reg (s->code, tree->reg1, X86_EAX, 4);
		x86_pop_reg (s->code, X86_EAX);
	}

}

#reg: ISINST (reg) {
#	guint8 *start = s->code, *l1, *l2, *l3, *l4, *le;
#	MonoClass *k = tree->data.klass;
#	int treg = tree->reg1;
#	gint32 i;
#
#	tree->is_jump = TRUE;
#	l1 = l2 = l3 = l4 = le = NULL;
#
#	for (i = 0; i < 2; i++) {
#		s->code = start;
#
#		x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, 0);
#		x86_branch8 (s->code, X86_CC_EQ, le - l1, FALSE);
#		l1 = s->code;
#	
#		x86_push_reg (s->code, tree->left->reg1);
#
#		if (k->flags & TYPE_ATTRIBUTE_INTERFACE) {
#			x86_mov_reg_membase (s->code, treg, treg, 0, 4); // treg = o->klass
#			x86_mov_reg_membase (s->code, treg, treg, G_STRUCT_OFFSET (MonoClass, max_interface_id), 4);
#			x86_alu_reg_imm (s->code, X86_CMP, treg, k->interface_id);
#			x86_branch8 (s->code, X86_CC_GE, l3 - l2, FALSE);
#			l2 = s->code;
#			x86_pop_reg (s->code, treg);
#			x86_alu_reg_reg (s->code, X86_XOR, treg, treg);
#			x86_jump8 (s->code, le - l3);
#			l3 = s->code;
#			x86_mov_reg_membase (s->code, treg, X86_ESP, 0, 4); // treg = o
#			x86_mov_reg_membase (s->code, treg, treg, 0, 4); // treg = o->klass
#			x86_mov_reg_membase (s->code, treg, treg, G_STRUCT_OFFSET (MonoClass, interface_offsets), 4);
#			x86_mov_reg_membase (s->code, treg, treg, (k->interface_id << 2), 4);
#			x86_alu_reg_imm (s->code, X86_CMP, treg, 0);
#			x86_pop_reg (s->code, treg);
#			x86_branch8 (s->code, X86_CC_NE, le - l4, FALSE);
#			l4 = s->code;
#			x86_alu_reg_reg (s->code, X86_XOR, treg, treg);
#		} else {
#			x86_mov_reg_membase (s->code, treg, treg, 0, 4); // treg = o->klass
#			x86_mov_reg_membase (s->code, treg, treg, G_STRUCT_OFFSET (MonoClass, baseval), 4);
#			x86_alu_reg_imm (s->code, X86_SUB, treg, k->baseval);
#			x86_alu_reg_imm (s->code, X86_CMP, treg, k->diffval);
#			x86_pop_reg (s->code, treg);
#			x86_branch8 (s->code, X86_CC_LE, le - l2, FALSE);
#			l2 = s->code;
#			x86_alu_reg_reg (s->code, X86_XOR, treg, treg);
#		}
#		
#		le = s->code;
#		//x86_breakpoint (s->code);
#	}
#}

stmt: INITOBJ (reg) {
	int i, j;

	i = tree->data.i;

	if (i == 1 || i == 2 || i == 4) {
		int t = X86_ECX;

		if (tree->left->reg1 != X86_EAX) 
			t = X86_EAX;

		x86_push_reg (s->code, t);
		x86_alu_reg_reg (s->code, X86_XOR, t, t);

		switch (tree->data.i) {
		case 4:
			x86_mov_regp_reg (s->code, tree->left->reg1, t, 4);
			break;
		case 2:
			x86_mov_regp_reg (s->code, tree->left->reg1, t, 4);
			break;
		case 1:
			x86_mov_regp_reg (s->code, tree->left->reg1, t, 4);
			break;
		}
		x86_pop_reg (s->code, t);

		return;
	}

	i = tree->data.i / 4;
	j = tree->data.i % 4;

	x86_push_reg (s->code, X86_EAX);
	
	if (tree->left->reg1 != X86_EDI) {
		x86_push_reg (s->code, X86_EDI);
		x86_mov_reg_reg (s->code, X86_EDI, tree->left->reg1, 4);
	}

	if (i) {
		x86_push_reg (s->code, X86_ECX);
		x86_alu_reg_reg (s->code, X86_XOR, X86_EAX, X86_EAX);
		x86_mov_reg_imm (s->code, X86_ECX, i);
		x86_cld (s->code);
		x86_prefix (s->code, X86_REP_PREFIX);
		x86_stosl (s->code);
		x86_pop_reg (s->code, X86_ECX);
	}


	for (i = 0; i < j; i++)
		x86_stosb (s->code);

	if (tree->left->reg1 != X86_EDI)
		x86_pop_reg (s->code, X86_EDI);
	
	x86_pop_reg (s->code, X86_EAX);
}

stmt: NOP

stmt: POP (reg)

stmt: BR {
	gint32 addr = tree->data.bb->addr - tree->addr - 5;
	tree->is_jump = 1;    
	
	x86_jump32 (s->code, addr); 
}

stmt: BLT (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - offset, TRUE); 
}

stmt: BLT (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - offset, TRUE); 
}

stmt: BLT_UN (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - offset, FALSE); 
}

stmt: BLT_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - offset, FALSE); 
}

stmt: BGT (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - offset, TRUE); 
}

stmt: BGT (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - offset, TRUE); 
}

stmt: BGT_UN (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - offset, FALSE); 
}

stmt: BGT_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - offset, FALSE); 
}

stmt: BEQ (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - offset, TRUE);
}

stmt: BEQ (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - offset, TRUE);
}

stmt: BNE_UN (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.bb->addr - offset, FALSE);
}

stmt: BNE_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.bb->addr - offset, FALSE);
}

stmt: BGE (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.bb->addr - offset, TRUE);
}

stmt: BGE (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.bb->addr - offset, TRUE);
}

stmt: BGE_UN (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.bb->addr - offset, FALSE);
}

stmt: BGE_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_GE, tree->data.bb->addr - offset, FALSE);
}

stmt: BLE (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.bb->addr - offset, TRUE);
}

stmt: BLE (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.bb->addr - offset, TRUE);
}

stmt: BLE_UN (reg, reg) 1 {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.bb->addr - offset, FALSE);
}

stmt: BLE_UN (reg, CONST_I4) "MB_USE_OPT1(0)" {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, tree->right->data.i);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_LE, tree->data.bb->addr - offset, FALSE);
}

stmt: BRTRUE (reg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, 0);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.bb->addr - offset, TRUE);
}

stmt: BRFALSE (reg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, 0);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - offset, TRUE);
}

stmt: BREAK {
	x86_breakpoint (s->code);
}

stmt: RET (reg) {
	if (tree->left->reg1 != X86_EAX)
		x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, s->epilog - 5);      
	}
}

stmt: RET_VOID {
	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, s->epilog - 5);
	} 
}

stmt: ARG_I4 (reg) {
	x86_push_reg (s->code, tree->left->reg1);
	PRINT_REG ("ARG_I4",  tree->left->reg1);
}

# fixme: we must free the allocated strings somewhere
stmt: ARG_STRING (reg) {
	x86_alu_reg_imm (s->code, X86_SUB, X86_ESP, 4);
	x86_push_reg (s->code, X86_EAX);
	x86_push_reg (s->code, X86_ECX);
	x86_push_reg (s->code, X86_EDX);

	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_string_to_utf8);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 4);
	
	x86_mov_membase_reg (s->code, X86_ESP, 12, X86_EAX, 4);

	x86_pop_reg (s->code, X86_EDX);
	x86_pop_reg (s->code, X86_ECX);
	x86_pop_reg (s->code, X86_EAX);
}

stmt: ARG_I4 (ADDR_G) {
	x86_push_imm (s->code, tree->left->data.p);
}

stmt: ARG_I4 (CONST_I4) "MB_USE_OPT1(0)" {
	x86_push_imm (s->code, tree->left->data.i);
}

this: reg {
	PRINT_REG ("THIS", tree->reg1);
}

this: NOP

reg: CALL_I4 (this, reg) {
	MethodCallInfo *ci = tree->data.ci;
	int treg = X86_EAX;
	int lreg = tree->left->reg1;
	int rreg = tree->right->reg1;
	
	if (lreg == treg || rreg == treg) 
		treg = X86_EDX;
	if (lreg == treg || rreg == treg) 
		treg = X86_ECX;
	if (lreg == treg || rreg == treg) 
		g_assert_not_reached ();

	if (ci->vtype_num) {
		int offset = g_array_index (s->varinfo, MonoVarInfo, ci->vtype_num).offset;
		x86_lea_membase (s->code, treg, X86_EBP, offset);
		x86_push_reg (s->code, treg);
	}

	if (tree->left->op != MB_TERM_NOP) {
		g_assert (lreg >= 0);
		x86_push_reg (s->code, lreg);
	}

	x86_call_reg (s->code, rreg);

	if (ci->args_size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, ci->args_size);
	
	PRINT_REG ("CALL_I4", tree->reg1);

	g_assert (tree->reg1 == X86_EAX);
}

reg: CALL_I4 (this, LDIND_I4 (ADDR_G)) {
	MethodCallInfo *ci = tree->data.ci;
	int lreg = tree->left->reg1;
	int treg = X86_EAX;

	if (lreg == treg) 
		treg = X86_EDX;
	
	if (ci->vtype_num) {
		int offset = g_array_index (s->varinfo, MonoVarInfo, ci->vtype_num).offset;
		x86_lea_membase (s->code, treg, X86_EBP, offset);
		x86_push_reg (s->code, treg);
	}

	if (tree->left->op != MB_TERM_NOP) {
		g_assert (lreg >= 0);
		x86_push_reg (s->code, lreg);
	}

	x86_call_mem (s->code, tree->right->left->data.p);

	if (ci->args_size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, ci->args_size);

	PRINT_REG ("CALL_I4", tree->reg1);

	g_assert (tree->reg1 == X86_EAX);
}

reg: CALL_I4 (this, INTF_ADDR) {
	MethodCallInfo *ci = tree->data.ci;
	int lreg = tree->left->reg1;
	int treg = X86_EAX;

	if (lreg == treg) 
		treg = X86_EDX;

	if (ci->vtype_num) {
		int offset = g_array_index (s->varinfo, MonoVarInfo, ci->vtype_num).offset;
		x86_lea_membase (s->code, treg, X86_EBP, offset);
		x86_push_reg (s->code, treg);
	}

	if (tree->left->op != MB_TERM_NOP) {
		g_assert (lreg >= 0);
		x86_push_reg (s->code, lreg);
	}

	x86_mov_reg_membase (s->code, lreg, lreg, 0, 4);
	x86_mov_reg_membase (s->code, lreg, lreg, 
	        G_STRUCT_OFFSET (MonoClass, interface_offsets), 4);
	x86_mov_reg_membase (s->code, lreg, lreg, tree->right->data.m->klass->interface_id << 2, 4);
	x86_call_virtual (s->code, lreg, tree->right->data.m->slot << 2);

	if (ci->args_size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, ci->args_size);

	PRINT_REG ("CALL_I4(INTERFACE)", tree->reg1);

	g_assert (tree->reg1 == X86_EAX);
}

reg: CALL_I4 (this, VFUNC_ADDR) {
	MethodCallInfo *ci = tree->data.ci;
	int lreg = tree->left->reg1;
	int treg = X86_EAX;

	if (lreg == treg) 
		treg = X86_EDX;

	if (ci->vtype_num) {
		int offset = g_array_index (s->varinfo, MonoVarInfo, ci->vtype_num).offset;
		x86_lea_membase (s->code, treg, X86_EBP, offset);
		x86_push_reg (s->code, treg);
	}

	if (tree->left->op != MB_TERM_NOP) {
		g_assert (lreg >= 0);
		x86_push_reg (s->code, lreg);
	}

	x86_mov_reg_membase (s->code, lreg, lreg, 0, 4);
	x86_call_virtual (s->code, lreg, 
	        G_STRUCT_OFFSET (MonoClass, vtable) + (tree->right->data.m->slot << 2));

	if (ci->args_size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, ci->args_size);

	PRINT_REG ("CALL_I4(VIRTUAL)", tree->reg1);

	g_assert (tree->reg1 == X86_EAX);
}

stmt: CALL_VOID (this, LDIND_I4 (ADDR_G)) {
	MethodCallInfo *ci = tree->data.ci;
	int lreg = tree->left->reg1;
	int treg = X86_EAX;

	if (lreg == treg) 
		treg = X86_EDX;
	
	if (tree->left->op != MB_TERM_NOP) {
		g_assert (lreg >= 0);
		x86_push_reg (s->code, lreg);
	}

	if (ci->vtype_num) {
		int offset = g_array_index (s->varinfo, MonoVarInfo, ci->vtype_num).offset;
		x86_lea_membase (s->code, treg, X86_EBP, offset);
		x86_push_reg (s->code, treg);
	}

	x86_call_mem (s->code, tree->right->left->data.p);

	if (ci->args_size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, ci->args_size);
}

stmt: CALL_VOID (this, INTF_ADDR) {
	MethodCallInfo *ci = tree->data.ci;
	int lreg = tree->left->reg1;
	int treg = X86_EAX;

	if (lreg == treg) 
		treg = X86_EDX;

	if (tree->left->op != MB_TERM_NOP) {
		g_assert (lreg >= 0);
		x86_push_reg (s->code, lreg);
	}

	if (ci->vtype_num) {
		int offset = g_array_index (s->varinfo, MonoVarInfo, ci->vtype_num).offset;
		x86_lea_membase (s->code, treg, X86_EBP, offset);
		x86_push_reg (s->code, treg);
	}


	x86_mov_reg_membase (s->code, lreg, lreg, 0, 4);
	x86_mov_reg_membase (s->code, lreg, lreg, 
	        G_STRUCT_OFFSET (MonoClass, interface_offsets), 4);
	x86_mov_reg_membase (s->code, lreg, lreg, tree->right->data.m->klass->interface_id << 2, 4);
	x86_call_virtual (s->code, lreg, tree->right->data.m->slot << 2);

	if (ci->args_size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, ci->args_size);
}

stmt: CALL_VOID (this, VFUNC_ADDR) {
	MethodCallInfo *ci = tree->data.ci;
	int lreg = tree->left->reg1;
	int treg = X86_EAX;

	if (lreg == treg) 
		treg = X86_EDX;

	if (tree->left->op != MB_TERM_NOP) {
		g_assert (lreg >= 0);
		x86_push_reg (s->code, lreg);
	}

	if (ci->vtype_num) {
		int offset = g_array_index (s->varinfo, MonoVarInfo, ci->vtype_num).offset;
		x86_lea_membase (s->code, treg, X86_EBP, offset);
		x86_push_reg (s->code, treg);
	}

	x86_mov_reg_membase (s->code, lreg, lreg, 0, 4);
	x86_call_virtual (s->code, lreg, 
	        G_STRUCT_OFFSET (MonoClass, vtable) + (tree->right->data.m->slot << 2));

	if (ci->args_size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, ci->args_size);
}

stmt: SWITCH (reg) {
	guint32 offset;
	guint32 *jt = (guint32 *)tree->data.p;

	tree->is_jump = 1;

	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, jt [0]);
	offset = 6 + (guint32)s->code;
	x86_branch32 (s->code, X86_CC_GE, jt [jt [0] + 1] - offset, FALSE);

	x86_mov_reg_memindex (s->code, X86_EAX, X86_NOBASEREG, 
			      tree->data.i + 4, tree->left->reg1, 2, 4);	
	x86_jump_reg (s->code, X86_EAX);
}

#
# 64 bit integers
#

reg: CONV_I4 (lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
} 

reg: CONV_OVF_I4 (lreg){
	/* 
	 * Valid ints: 0xffffffff:8000000 to 00000000:0x7f000000
	 */
	x86_test_reg_reg (s->code, tree->left->reg1, tree->left->reg1);

	/* If the low word top bit is set, see if we are negative */
	x86_branch8 (s->code, X86_CC_LT, 14, TRUE);
	
	/* We are not negative (no top bit set, check for our top word to be zero */
	x86_test_reg_reg (s->code, tree->left->reg2, tree->left->reg2);
	x86_branch8 (s->code, X86_CC_EQ, 15, TRUE);

	/* throw exception */
	x86_mov_reg_imm (s->code, X86_ECX, get_exception_overflow ());
	x86_call_code (s->code, get_throw_exception ());
	
	/* our top bit is set, check that top word is 0xfffffff */
	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg2, 0xffffffff);

	/* nope, emit exception */
	x86_branch8 (s->code, X86_CC_NE, -15, TRUE);

	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
}

reg: CONV_OVF_U4 (lreg) {
	/* top word must be 0 */
	x86_test_reg_reg (s->code, tree->left->reg2, tree->left->reg2);
	x86_branch8 (s->code, X86_CC_EQ, 15, TRUE);

	x86_mov_reg_imm (s->code, X86_ECX, get_exception_overflow ());
	x86_call_code (s->code, get_throw_exception ());

	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
}

stmt: POP (lreg)

lreg: CONST_I8 1 {
	x86_mov_reg_imm (s->code, tree->reg1, *((gint32 *)&tree->data.p));
	x86_mov_reg_imm (s->code, tree->reg2, *((gint32 *)&tree->data.p + 1));
}

lreg: CONV_I8 (CONST_I4) {
	x86_mov_reg_imm (s->code, tree->reg1, tree->left->data.i);

	if (tree->left->data.i >= 0)
		x86_alu_reg_reg (s->code, X86_XOR, tree->reg2, tree->reg2);
	else 
		x86_mov_reg_imm (s->code, tree->reg2, -1);		
}

lreg: CONV_I8 (reg) {
	guint8 *i1;

	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);

	x86_alu_reg_imm (s->code, X86_CMP, tree->left->reg1, 0);
	x86_alu_reg_reg (s->code, X86_XOR, tree->reg2, tree->reg2);
	x86_branch8 (s->code, X86_CC_GE, 5, TRUE);
	i1 = s->code;
	x86_mov_reg_imm (s->code, tree->reg2, -1); 
	g_assert ((s->code - i1) == 5);
}

lreg: CONV_U8 (CONST_I4) 1 {
	x86_mov_reg_imm (s->code, tree->reg1, tree->left->data.i);
	x86_alu_reg_reg (s->code, X86_XOR, tree->reg2, tree->reg2);
}

lreg: CONV_OVF_U8 (CONST_I4) {
	if (tree->left->data.i < 0){
		x86_mov_reg_imm (s->code, X86_ECX, get_exception_overflow ());
		x86_call_code (s->code, get_throw_exception ());
	} else {
		x86_mov_reg_imm (s->code, tree->reg1, tree->left->data.i);
		x86_alu_reg_reg (s->code, X86_XOR, tree->reg2, tree->reg2);
	}
}

lreg: CONV_OVF_I8_UN (CONST_I4) {
	x86_mov_reg_imm (s->code, tree->reg1, tree->left->data.i);
	x86_alu_reg_reg (s->code, X86_XOR, tree->reg2, tree->reg2);
}

lreg: CONV_OVF_U8 (reg) {
	x86_test_reg_imm (s->code, tree->left->reg1, 0x8000000);
	x86_branch8 (s->code, X86_CC_EQ, 10, TRUE);
	x86_mov_reg_imm (s->code, X86_ECX, get_exception_overflow ());
	x86_call_code (s->code, get_throw_exception ());

	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_XOR, tree->reg2, tree->reg2);
}

lreg: CONV_OVF_I8_UN (reg) {
	/* Convert uint value into int64, we pass everything */
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	x86_alu_reg_reg (s->code, X86_XOR, tree->reg2, tree->reg2);
}

stmt: STIND_I8 (addr, lreg) {
       
	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_mem_reg (s->code, tree->left->data.ainfo.offset, tree->right->reg1, 4);
		x86_mov_mem_reg (s->code, tree->left->data.ainfo.offset + 4, tree->right->reg2, 4);
		break;
		
	case AMBase:
		x86_mov_membase_reg (s->code, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset, tree->right->reg1, 4);
		x86_mov_membase_reg (s->code, tree->left->data.ainfo.basereg, 
				     tree->left->data.ainfo.offset + 4, tree->right->reg2, 4);
		break;		
	case AMIndex:
		x86_mov_memindex_reg (s->code, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 4);
		x86_mov_memindex_reg (s->code, X86_NOBASEREG, tree->left->data.ainfo.offset + 4,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg2, 4);
		break;		
	case AMBaseIndex:
		x86_mov_memindex_reg (s->code, tree->left->data.ainfo.basereg, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg1, 4);
		x86_mov_memindex_reg (s->code, tree->left->data.ainfo.basereg, tree->left->data.ainfo.offset + 4,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift,
				      tree->right->reg2, 4);
		break;		
	}

}

# an addr can use two address register (base and index register). The must take care 
# that we do not override them (thus the use of x86_lea)
lreg: LDIND_I8 (addr) {

	switch (tree->left->data.ainfo.amode) {

	case AMImmediate:
		x86_mov_reg_mem (s->code, tree->reg1, tree->left->data.ainfo.offset, 4);
		x86_mov_reg_mem (s->code, tree->reg2, tree->left->data.ainfo.offset + 4, 4);
		break;

	case AMBase:
		x86_lea_membase (s->code, tree->reg2, tree->left->data.ainfo.basereg,
				 tree->left->data.ainfo.offset);
		x86_mov_reg_membase (s->code, tree->reg1, tree->reg2, 0, 4);
		x86_mov_reg_membase (s->code, tree->reg2, tree->reg2, 4, 4);
		break;		
	case AMIndex:
		x86_lea_memindex (s->code, tree->reg2, X86_NOBASEREG, tree->left->data.ainfo.offset,
				      tree->left->data.ainfo.indexreg, tree->left->data.ainfo.shift);
		x86_mov_reg_membase (s->code, tree->reg1, tree->reg2, 0, 4);
		x86_mov_reg_membase (s->code, tree->reg2, tree->reg2, 4, 4);
		break;		
	case AMBaseIndex:
		x86_lea_memindex (s->code, tree->reg2, tree->left->data.ainfo.basereg, 
				  tree->left->data.ainfo.offset, tree->left->data.ainfo.indexreg, 
				  tree->left->data.ainfo.shift);
		x86_mov_reg_membase (s->code, tree->reg1, tree->reg2, 0, 4);
		x86_mov_reg_membase (s->code, tree->reg2, tree->reg2, 4, 4);
		break;		
	}
	PRINT_REG ("LDIND_I8_0", tree->reg1);
	PRINT_REG ("LDIND_I8_1", tree->reg2);
}

lreg: ADD (lreg, lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_alu_reg_reg (s->code, X86_ADD, tree->reg1, tree->right->reg1);
	x86_alu_reg_reg (s->code, X86_ADC, tree->reg2, tree->right->reg2);
}

lreg: SUB (lreg, lreg) {
	PRINT_REG ("LSUB0",  tree->left->reg1);
	PRINT_REG ("LSUB1",  tree->left->reg2);
	PRINT_REG ("LSUB2",  tree->right->reg1);
	PRINT_REG ("LSUB3",  tree->right->reg2);
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_alu_reg_reg (s->code, X86_SUB, tree->reg1, tree->right->reg1);
	x86_alu_reg_reg (s->code, X86_SUB, tree->reg2, tree->right->reg2);
}

lreg: AND (lreg, lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_alu_reg_reg (s->code, X86_AND, tree->reg1, tree->right->reg1);
	x86_alu_reg_reg (s->code, X86_AND, tree->reg2, tree->right->reg2);
}

lreg: OR (lreg, lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_alu_reg_reg (s->code, X86_OR, tree->reg1, tree->right->reg1);
	x86_alu_reg_reg (s->code, X86_OR, tree->reg2, tree->right->reg2);
}

lreg: NEG (lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	x86_neg_reg (s->code, tree->reg1);
	x86_alu_reg_imm (s->code, X86_ADC, tree->reg2, 0);
	x86_neg_reg (s->code, tree->reg2);
}

lreg: NOT (lreg) {
	if (tree->reg1 != tree->left->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
	if (tree->reg2 != tree->left->reg2)
		x86_mov_reg_reg (s->code, tree->reg2, tree->left->reg2, 4);
	 x86_not_reg (s->code, tree->reg1);
	 x86_not_reg (s->code, tree->reg2);
}

lreg: MUL (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_llmult);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: DIV (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_lldiv);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: REM (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_llrem);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: DIV_UN (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_lldiv_un);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: REM_UN (lreg, lreg) {
	if (mono_regset_reg_used (s->rs, X86_ECX)) 
		x86_push_reg (s->code, X86_ECX);

	x86_push_reg (s->code, tree->right->reg2);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, mono_llrem_un);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 16);

	if (mono_regset_reg_used (s->rs, X86_ECX))
		x86_pop_reg (s->code, X86_ECX);
}

lreg: CALL_I8 (this, LDIND_I4 (ADDR_G)) {
	MethodCallInfo *ci = tree->data.ci;
	int lreg = tree->left->reg1;
	int treg = X86_EAX;

	if (lreg == treg) 
		treg = X86_EDX;
	
	if (ci->vtype_num) {
		int offset = g_array_index (s->varinfo, MonoVarInfo, ci->vtype_num).offset;
		x86_lea_membase (s->code, treg, X86_EBP, offset);
		x86_push_reg (s->code, treg);
	}

	if (tree->left->op != MB_TERM_NOP) {
		g_assert (lreg >= 0);
		x86_push_reg (s->code, lreg);
	}

	x86_call_mem (s->code, tree->right->left->data.p);

	if (ci->args_size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, ci->args_size);

	g_assert (tree->reg1 == X86_EAX);
	g_assert (tree->reg2 == X86_EDX);
}

stmt: RET (lreg) {
	if (tree->left->reg1 != X86_EAX) {
		if (tree->left->reg2 != X86_EAX) {
			x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);
			if (tree->left->reg2 != X86_EDX)
				x86_mov_reg_reg (s->code, X86_EDX, tree->left->reg2, 4);
		} else { 
			x86_mov_reg_reg (s->code, X86_ECX, tree->left->reg2, 4);
			x86_mov_reg_reg (s->code, X86_EAX, tree->left->reg1, 4);
			x86_mov_reg_reg (s->code, X86_EDX, X86_ECX, 4);
		}
	} else if (tree->left->reg2 != X86_EDX) {
		x86_mov_reg_reg (s->code, X86_EDX, tree->left->reg2, 4);
	}

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, s->epilog - 5);      
	}
}


stmt: ARG_I8 (lreg) {
	x86_push_reg (s->code, tree->left->reg2);
	x86_push_reg (s->code, tree->left->reg1);
}

stmt: BEQ (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		o1 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, o2 - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - o2, TRUE);
	}
}

stmt: BNE_UN (lreg, lreg) {
	gint32 offset;

	tree->is_jump = 1;

	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
	offset = 6 + s->code - s->start;
	x86_branch8 (s->code, X86_CC_NE, tree->data.bb->addr - offset, FALSE);
	x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.bb->addr - offset, FALSE);
}

stmt: BGE (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - o1, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GE, tree->data.bb->addr - oe, FALSE);
	}
}

stmt: BGE_UN (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GE, tree->data.bb->addr - oe, FALSE);
	}
}

stmt: BGT (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - o1, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - oe, FALSE);
	}
}

stmt: BGT_UN (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_GT, tree->data.bb->addr - oe, FALSE);
	}
}

stmt: BLT (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - o1, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - oe, FALSE);
	}
}

stmt: BLT_UN (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - oe, FALSE);
	}
}

stmt: BLE (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - o1, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, TRUE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LE, tree->data.bb->addr - oe, FALSE);
	}
}

stmt: BLE_UN (lreg, lreg) {
	guint8 *start = s->code;
	gint32 o1, o2, oe, i;

	tree->is_jump = 1;

	for (i = 0; i < 2; i ++) {
		s->code = start;
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o1 = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LT, tree->data.bb->addr - o1, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg2, tree->right->reg2);
		o2 = 2 + s->code - s->start;
		x86_branch8 (s->code, X86_CC_NE, oe - o2, FALSE);
		x86_alu_reg_reg (s->code, X86_CMP, tree->left->reg1, tree->right->reg1);
		oe = 6 + s->code - s->start;
		x86_branch32 (s->code, X86_CC_LE, tree->data.bb->addr - oe, FALSE);
	}
}

#
# floating point 

#stmt: STLOC (CONV_I4 (freg)) {
#	// fixme: set CW
#	x86_fist_pop_membase (s->code, X86_EBP, tree->data.i, FALSE);
#} 

reg: CONV_I4 (freg) {
	x86_push_reg (s->code, X86_EAX); // SP = SP - 4
	x86_fist_pop_membase (s->code, X86_ESP, 0, FALSE);
	x86_pop_reg (s->code, tree->reg1);
}

reg: CEQ (freg, freg) {
	int treg = tree->reg1;
	
	if (treg != X86_EAX)
		x86_push_reg (s->code, X86_EAX); // save EAX
		
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	x86_alu_reg_imm (s->code, X86_CMP, X86_EAX, 0x4000);
	x86_set_reg (s->code, X86_CC_EQ, tree->reg1, TRUE);
	x86_widen_reg (s->code, treg, treg, FALSE, FALSE);

	if (treg != X86_EAX)
		x86_pop_reg (s->code, X86_EAX); // save EAX
}

freg: CONV_R8 (freg) {
	/* nothing to do */
}

freg: CONV_R8 (LDIND_I4 (ADDR_G)) {
	x86_fild (s->code, tree->left->left->data.p, FALSE);
}

freg: CONV_R8 (reg) {
	/* I found no direct way to move an integer register to 
	 * the floating point stack, so we need to store the register
	 * to memory
	 */
	x86_push_reg (s->code, tree->left->reg1);
	x86_fild_membase (s->code, X86_ESP, 0, FALSE);
	x86_alu_reg_imm (s->code, X86_SUB, X86_ESP, 4);
}

freg: CONV_R4 (reg) {
	/* I found no direct way to move an integer register to 
	 * the floating point stack, so we need to store the register
	 * to memory
	 */
	x86_push_reg (s->code, tree->left->reg1);
	x86_fild_membase (s->code, X86_ESP, 0, FALSE);
	x86_alu_reg_imm (s->code, X86_SUB, X86_ESP, 4);
}

freg: CONST_R4 {
	float f = *(float *)tree->data.p;

	if (f == 0.0)
		x86_fldz (s->code);
	else if (f == 1.0)
		x86_fld1(s->code);
	else
		x86_fld (s->code, tree->data.p, FALSE);
}

freg: CONST_R8 {
	double d = *(double *)tree->data.p;

	if (d == 0.0)
		x86_fldz (s->code);
	else if (d == 1.0)
		x86_fld1(s->code);
	else
		x86_fld (s->code, tree->data.p, TRUE);
}

freg: LDIND_R4 (reg) {
	x86_fld_membase (s->code, tree->left->reg1, 0, FALSE);
}

freg: LDIND_R8 (reg) {
	x86_fld_membase (s->code, tree->left->reg1, 0, TRUE);
}

freg: LDIND_R8 (reg) {
	x86_fld_membase (s->code, tree->left->reg1, 0, TRUE);
}

freg: ADD (freg, freg) {
	x86_fp_op_reg (s->code, X86_FADD, 1, TRUE);
}

freg: SUB (freg, freg) {
	x86_fp_op_reg (s->code, X86_FSUB, 1, TRUE);
}

freg: MUL (freg, freg) {
	x86_fp_op_reg (s->code, X86_FMUL, 1, TRUE);
}

freg: DIV (freg, freg) {
	x86_fp_op_reg (s->code, X86_FDIV, 1, TRUE);
}

#freg: REM (freg, freg) {
# this does not work, since it does not pop a value from the stack,
# and we need to test if the instruction is ready
#	x86_fprem1 (s->code);
#}

freg: NEG (freg) {
	x86_fchs (s->code);
}

stmt: POP (freg)

stmt: STIND_R4 (reg, freg) {
	x86_fst_membase (s->code, tree->left->reg1, 0, FALSE, TRUE);
}

stmt: STIND_R8 (reg, freg) {
	x86_fst_membase (s->code, tree->left->reg1, 0, TRUE, TRUE);
}

stmt: ARG_R4 (freg) {
	x86_alu_reg_imm (s->code, X86_SUB, X86_ESP, 4);
	x86_fst_membase (s->code, X86_ESP, 0, FALSE, TRUE);
}

stmt: ARG_R8 (freg) {
	x86_alu_reg_imm (s->code, X86_SUB, X86_ESP, 8);
	x86_fst_membase (s->code, X86_ESP, 0, TRUE, TRUE);
}

stmt: BEQ (freg, freg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	x86_alu_reg_imm (s->code, X86_CMP, X86_EAX, 0x4000);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - offset, TRUE);
}

stmt: BNE_UN (freg, freg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	x86_alu_reg_imm (s->code, X86_CMP, X86_EAX, 0x4000);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.bb->addr - offset, FALSE);
}

stmt: BLT (freg, freg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - offset, TRUE);
}

stmt: BLT_UN (freg, freg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - offset, FALSE);
}

stmt: BGE_UN (freg, freg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.bb->addr - offset, FALSE);
}

stmt: BGT_UN (freg, freg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	x86_alu_reg_imm (s->code, X86_CMP, X86_EAX, 0x0100);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_EQ, tree->data.bb->addr - offset, FALSE);
}

stmt: BLE_UN (freg, freg) {
	gint32 offset;

	tree->is_jump = 1;
	x86_fcompp (s->code);
	x86_fnstsw (s->code);
	x86_alu_reg_imm (s->code, X86_AND, X86_EAX, 0x4500);
	offset = 6 + s->code - s->start;
	x86_branch32 (s->code, X86_CC_NE, tree->data.bb->addr - offset, FALSE);
}

freg: CALL_R8 (this, LDIND_I4 (ADDR_G)) {
	MethodCallInfo *ci = tree->data.ci;
	int lreg = tree->left->reg1;
	int treg = X86_EAX;

	if (lreg == treg) 
		treg = X86_EDX;
	
	if (ci->vtype_num) {
		int offset = g_array_index (s->varinfo, MonoVarInfo, ci->vtype_num).offset;
		x86_lea_membase (s->code, treg, X86_EBP, offset);
		x86_push_reg (s->code, treg);
	}

	if (tree->left->op != MB_TERM_NOP) {
		g_assert (lreg >= 0);
		x86_push_reg (s->code, lreg);
	}

	x86_call_mem (s->code, tree->right->left->data.p);

	if (ci->args_size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, ci->args_size);
}

freg: CALL_R8 (this, INTF_ADDR) {
	MethodCallInfo *ci = tree->data.ci;
	int lreg = tree->left->reg1;
	int treg = X86_EAX;

	if (lreg == treg) 
		treg = X86_EDX;

	if (ci->vtype_num) {
		int offset = g_array_index (s->varinfo, MonoVarInfo, ci->vtype_num).offset;
		x86_lea_membase (s->code, treg, X86_EBP, offset);
		x86_push_reg (s->code, treg);
	}

	if (tree->left->op != MB_TERM_NOP) {
		g_assert (lreg >= 0);
		x86_push_reg (s->code, lreg);
	}

	x86_mov_reg_membase (s->code, lreg, lreg, 0, 4);
	x86_mov_reg_membase (s->code, lreg, lreg, 
	        G_STRUCT_OFFSET (MonoClass, interface_offsets), 4);
	x86_mov_reg_membase (s->code, lreg, lreg, tree->right->data.m->klass->interface_id << 2, 4);
	x86_call_virtual (s->code, lreg, tree->right->data.m->slot << 2);

	if (ci->args_size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, ci->args_size);
}

freg: CALL_R8 (this, VFUNC_ADDR) {
	MethodCallInfo *ci = tree->data.ci;
	int lreg = tree->left->reg1;
	int treg = X86_EAX;

	if (lreg == treg) 
		treg = X86_EDX;

	if (ci->vtype_num) {
		int offset = g_array_index (s->varinfo, MonoVarInfo, ci->vtype_num).offset;
		x86_lea_membase (s->code, treg, X86_EBP, offset);
		x86_push_reg (s->code, treg);
	}

	if (tree->left->op != MB_TERM_NOP) {
		g_assert (lreg >= 0);
		x86_push_reg (s->code, lreg);
	}

	x86_mov_reg_membase (s->code, lreg, lreg, 0, 4);
	x86_call_virtual (s->code, lreg, 
	        G_STRUCT_OFFSET (MonoClass, vtable) + (tree->right->data.m->slot << 2));

	if (ci->args_size)
		x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, ci->args_size);
}

stmt: RET (freg) {

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, s->epilog - 5);      
	}
}

# support for value types

reg: LDIND_OBJ (reg) {
	if (tree->left->reg1 != tree->reg1)
		x86_mov_reg_reg (s->code, tree->reg1, tree->left->reg1, 4);
}

stmt: STIND_OBJ (reg, reg) {
	x86_push_reg (s->code, X86_EAX);
	x86_push_reg (s->code, X86_EDX);
	x86_push_reg (s->code, X86_ECX);

	g_assert (tree->data.i > 0);
	x86_push_imm (s->code, tree->data.i);
	x86_push_reg (s->code, tree->right->reg1);
	x86_push_reg (s->code, tree->left->reg1);
	x86_call_code (s->code, MEMCOPY);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 12);

	x86_pop_reg (s->code, X86_ECX);
	x86_pop_reg (s->code, X86_EDX);
	x86_pop_reg (s->code, X86_EAX);
}

stmt: ARG_OBJ (CONST_I4) {
	x86_push_imm (s->code, tree->left->data.i);	
}

stmt: ARG_OBJ (reg) {
	int size = tree->data.i;
	int sa;
	
	g_assert (size > 0);

	sa = size + 3;
	sa &= ~3;

	/* reserve space for the argument */
	x86_alu_reg_imm (s->code, X86_SUB, X86_ESP, sa);

	x86_push_reg (s->code, X86_EAX);
	x86_push_reg (s->code, X86_EDX);
	x86_push_reg (s->code, X86_ECX);

	x86_push_imm (s->code, size);
	x86_push_reg (s->code, tree->left->reg1);
	x86_lea_membase (s->code, X86_EAX, X86_ESP, 5*4);
	x86_push_reg (s->code, X86_EAX);

	x86_call_code (s->code, MEMCOPY);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 12);

	x86_pop_reg (s->code, X86_ECX);
	x86_pop_reg (s->code, X86_EDX);
	x86_pop_reg (s->code, X86_EAX);
}

stmt: RET_OBJ (reg) {
	int size = tree->data.i;

	x86_push_imm (s->code, size);
	x86_push_reg (s->code, tree->left->reg1);
	x86_push_membase (s->code, X86_EBP, 8);

	x86_call_code (s->code, MEMCOPY);
	x86_alu_reg_imm (s->code, X86_ADD, X86_ESP, 12);

	if (!tree->last_instr) {
		tree->is_jump = 1;
		x86_jump32 (s->code, s->epilog - 5);      
	}
}

%% 

#include "jit.h"

gint64 
mono_llmult (gint64 a, gint64 b)
{
	return a * b;
}

gint64 
mono_lldiv (gint64 a, gint64 b)
{
	return a / b;
}

gint64 
mono_llrem (gint64 a, gint64 b)
{
	return a % b;
}

guint64 
mono_lldiv_un (guint64 a, guint64 b)
{
	return a / b;
}

guint64 
mono_llrem_un (guint64 a, guint64 b)
{
	return a % b;
}

MBTree *
mono_ctree_new (MonoMemPool *mp, int op, MBTree *left, MBTree *right)
{
	MBTree *t = mono_mempool_alloc0 (mp, sizeof (MBTree));

	t->op = op;
	t->left = left;
	t->right = right;
	t->reg1 = -1;
	t->reg2 = -1;
	t->reg3 = -1;
	t->svt = VAL_UNKNOWN;
	t->cli_addr = -1;
	return t;
}

MBTree *
mono_ctree_new_leaf (MonoMemPool *mp, int op)
{
	return mono_ctree_new (mp, op, NULL, NULL);
}

static void
throw_exception (unsigned long eax, unsigned long ecx, unsigned long edx, unsigned long ebx,
		 unsigned long esi, unsigned long edi, unsigned long ebp, unsigned long eip,
		 unsigned long esp)
{
	MonoObject *exc = (gpointer)ecx;
	struct sigcontext ctx;
	
	ctx.esp = esp;
	ctx.eip = eip;
	ctx.ebp = ebp;
	ctx.edi = edi;
	ctx.esi = esi;
	ctx.ebx = ebx;
	ctx.edx = edx;
	ctx.ecx = ecx;
	ctx.eax = eax;
	
	arch_handle_exception (&ctx, exc);

	g_assert_not_reached ();
}

gpointer 
get_throw_exception (void)
{
	static guint8 *start = NULL;
	guint8 *code;

	if (start)
		return start;

	code = start = g_malloc (1024);

	x86_push_reg (code, X86_ESP);
	x86_push_membase (code, X86_ESP, 4); /* IP */
	x86_push_reg (code, X86_EBP);
	x86_push_reg (code, X86_EDI);
	x86_push_reg (code, X86_ESI);
	x86_push_reg (code, X86_EBX);
	x86_push_reg (code, X86_EDX);
	x86_push_reg (code, X86_ECX);
	x86_push_reg (code, X86_EAX);
	x86_call_code (code, throw_exception);
	/* we should never reach this breakpoint */
	x86_breakpoint (code);

	return start;
}

#ifdef DEBUG
void *
MEMCOPY (void *dest, const void *src, size_t n)
{
	int i, l = n;

	printf ("MEMCPY(%p to %p [%d]) ", src, dest, n);

	for (i = 0; i < l; i++)
		printf ("%02x ", *((guint8 *)src + i));
	printf ("\n");
	
	return memcpy (dest, src, n);
}
#endif


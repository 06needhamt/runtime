** Basics

Q: What is Mono exactly?

A: The Mono Project is a community initiative to develop an open
   source, Linux-based version of the Microsoft.NET development
   platform.  Its objective is to enable Linux developers to build and
   deploy cross platform .NET Applications.  The project will
   implement various technologies developed by Microsoft that have now
   been submitted to the ECMA for standardization.

Q: Is Mono a .NET implementation?

A: No.  Microsoft.Net is a broad, company-wide effort that ranges from
   development tools to end user applications.  Some components of
   this initiative have been announced and some others are in the
   works.


Q: What technologies are included in Mono?

A: Mono contains a number of components useful for building new
   software:

	<ul>
		* A Common Language Infrastructure (CLI) virtual
		  machine that contains a class loader, Just-in-time
		  compiler, and a garbage collecting runtime.

		* A class library that can work with any language
		  which works on the CLR.

		* A compiler for the C# language.  In the future we
		  might work on other compilers that target the Common
		  Language Runtime.


	</ul>


   Windows has compilers that target the virtual machine from <a
href="http://msdn.microsoft.com/net/thirdparty/default.asp#lang">a
   number of languages:</a> Managed C++, Java Script, Eiffel,
   Component Pascal, APL, Cobol, Oberon, Perl, Python, Scheme,
   Smalltalk, Standard ML, Haskell, Mercury and Oberon.

   The CLR and the Common Type System (CTS) enables applications and
   libraries to be written in a collection of different languages that
   target the byte code

   This means for example that if you define a class to do algebraic
   manipulation in C#, that class can be reused from any other
   language that supports the CLI.  You could create a class in C#,
   subclass it in C++ and instantiate it in an Eiffel program. 

   A single object system, threading system, class libraries, and
   garbage collection system can be shared across all these languages.
   
Q: Where can I find the specification for these technologies?

A: You can find the work-in-progress documentation from the T3G ECMA
   group here:
 
   <a href="http://www.dotnetexperts.com">http://www.dotnetexperts.com</a>

Q: Will you implement the .NET Framework SDK class libraries?

A: Yes, we will be implementing the APIs of the .NET Framework SDK
   class libraries. 

Q: What does Mono stand for?

A: Mono is the word for `Monkey' in Spanish. We like monkeys.

   It only means a number of other things: monochromatic (hence the
   gray theme used in the Web site).

Q: When will you ship it?

A: It is premature to target a shipdate for the code. While we anticipate
   availability in the middle of next year, the more contributions we
   get to the project, the sooner it will ship.

Q: How can I contribute?

A: Check the <a href="contributing.html">contributing</a> section. 

Q: Aren't you just copying someone else's work?

A: We are interested in providing the best tools for programmers to
   develop applications for Free Operating Systems.  We also want to help
   provide the interoperability that will allow those systems to fit in
   with other standards.

   Please read the <a href="http://www.go-mono.com/rationale.html">Mono
   Project white paper</a> on Ximian site] for more background and the
   rationale for the project.

** The Ximian role in the Mono Project

Q: Why is Ximian working on .NET?

A: We are interested in providing the best tools for programmers to
   develop applications for Free Operating Systems.  

   For more information, read the project <a
   href="rationale.html">rationale</a> page.

Q: Will Ximian be able to take on a project of this size?  

A: Ximian cannot and will not be able to take on the whole project on
   its own.  Ximian is spearheading the effort and providing a call to
   action.  Mono will be a free software/open source community
   project; that is the only way to implement something of this
   size. Visit the <a href="contributing.html">contributing</a> page
   on this site to learn more about what you can do.

Q: What pieces will Ximian be working on?

A: We will devote most of our resources to work on the pieces which are
   on the critical path to release a development and execution environment.

   The idea is to get Mono to a state of that would allow
   third parties to actually be able to use it real-world development.


** Relationship with GNOME

Q: How is this related to GNOME?

A: In a number of ways.  This project was born out of the need of
   providing improved tools for the GNOME community, and will use
   existing components that have been developed for GNOME when they
   are available.  For example, we plan to use Gtk+ and Libart to
   implement Winforms and the Drawing2D API and are considering
   GObject support.

Q: Has the GNOME Foundation or the GNOME team adopted Mono?

A: Mono is too new to be adopted by those groups. We hope that the
   tools that we will provide will be adopted by free software
   programmers including the GNOME Foundation members and the GNOME
   project generally.

Q: Should GNOME programmers switch over to Mono now?

A: It is still far to early for discussions of "switching over."  No
   pieces of Mono will be ready within the next six months, and a
   complete implementation is roughly one year away.

   We encourage GNOME developers to continue using the existing tools,
   libraries and components.  Improvements made to GNOME will have an
   impact on Mono, as they would be the "backend" for various classes.

Q: Will Mono include compatibility with Bonobo components? What is the
   relationship between Mono and Bonobo?

A: Yes, we will provide a set of classes for implementing and using
   Bonobo components from within Mono.  Mono should allow you to write
   Bonobo components more easily, just like .NET on Windows allows you
   to export .NET components to COM.

** Mono and Microsoft: .NET, Hailstorm, and Passport

Q: If applications use Mono, does that mean that I have to pay a service fee?

A: No.  Mono is not related to Microsoft's initiative of
   software-as-a-service.  It is going to provide an open source,
   Linux-based version of the Microsoft.NET development platform.  Its
   objective is to enable Linux developers to build and deploy cross
   platform .NET Applications.

Q: Is the Mono Project is related to the Microsoft Hailstorm effort?  Is
   Ximian endorsing Hailstorm?  

A: No.  The Mono Project is focused on providing a compatible set of
   tools for the Microsoft.NET development platform.  It does not
   address, require, or otherwise endorse the MS Passport-based
   Hailstorm single sign-on system that is part of Windows XP and
   other services.

Q: If you implement .NET, will I depend on Microsoft Passport to run my software?

A: No. MS Passport is unrelated to running .NET compatible applications
   produced with the Mono tools.  The only thing you will need is a
   just-in-time compiler (JIT).

Q: Is .NET just a bunch of marketing slogans?

A: Although the `.NET initiative' is still quite nebulous, The .NET Framework
   has been available for some time.  Mono is not an implementation of the .NET
   initiative, just the development framework.

Q: What is a 100% .NET application?

A: A `100% .NET application' is one that only uses the APIs defined
   under the System namespace and does not use PInvoke.  These
   applications would in theory run unmodified on Windows, Linux,
   HP-UX, Solaris, MacOS X and others. 

Q: If Microsoft will release a port of their .NET platform under the
   `Shared Source' license, why should I bother with anything else?

A: The Shared Source implementation will be expensive and its uses
   will be tightly restricted, especially for commercial use. We are
   working towards an implementation that will grant a number of
   important rights to recipients: use for any purpose,
   redistribution, modification, and redistribution of modifications.

   This is what we call <a
   href="http://www.gnu.org/philosophy/free-sw.html">Free Software</a>

Q: Is Mono a free implementation of Passport?

A: No.  Passport is part of Microsoft's Hailstorm initiative.  Mono
   is just a runtime, a compiler and a set of class libraries. 

Q: Will the System.Web.Security.PassportIdentity class mean
   that my software will depend on Passport?
   
A: No.  Applications may use that API to contact a Passport site, but
   are not required to do so.

   As long as your application does not use Passport, you will not
   need Passport.  

   It might even be possible to implement that class with
   a set of dummy functions, or use an alternate Passport implementation.

   We do not know at this time whether the Passport protocol is
   documented and whether we will be able to talk to
   passport.com 

Q: Will Mono running on Linux make Passport available for Linux?

A: No.  However, the Passport toolkit for Linux-based web servers is available from
   Microsoft.  


** Mono and Portable.NET

Q: What are the differences between Mono and Portable.NET?

A: Most of Mono is being written using C#, the only pieces written in
   C are those who have to absolutely be built using C (The JIT
   engine, the runtime, the interfaces to the garbage collection
   system).

   The C# compiler and the tools will become reusable C# components.

   Portable.NET is building its components out of C pieces.

** Mono and Windows

Q: Will Mono allow me to run Microsoft Office on Linux?

A: No, it will not.  Microsoft Office is a Windows application.  To
   learn more about running Windows applications on Intel Unix systems
   refer to <a href="http://www.winehq.com">the Wine Project</a>.

** Web Services

Q: Is Mono just a new way of writing Web Services?

A: No.

Q: If Mono implements the SDK classes, will I be able to write and
   execute .NET Web Services with it?
   
A: Yes.  When the project is finished, you will be able to use the
   same technologies that are available through the .NET Framework SDK
   on Windows to write Web Services.

Q: What about Soup?  Can I use Soup without Mono?

A: Soup is a library for GNOME applications to create SOAP servers and
   SOAP clients, and can be used without Mono.  You can browse the
   source code for soup using <a
   href="http://cvs.gnome.org/bonsai">GNOME's Bonsai</a>.

Q: Can I use CORBA?

A: Yes. The CLI contains enough information about a class that
   exposing it to other RPC systems (like CORBA) is really simple, and
   does not even require support from an object.  

   We will be implementing CORBA interoperation as an extension to the
   Mono classes so that we can integrate with Bonobo, just like
   Microsoft provides COM interoperation classes and support
   mechanisms. 

Q: Can I serialize my objects to other things other than XML?

A: Yes, although the serializing tools have not yet been planned, and
you would probably have to implement them yourself.

** Development Tools and Issues

Q: Will it be possible to use the CLI features without using bytecodes
   or the JIT?

A: Yes. The CLI engine will be made available as a shared library.
   The garbage collection engine, the threading abstraction, the
   object system, the dynamic type code system and the JIT will be
   available for C developers to integreate with their applications if
   they wish to do so. 

Q: Will you have new development tools?

A: With any luck, Free Software enthusiasts will contribute tools to
   improve the developer environment.  These tools could be developed
   initially using the Microsoft implementation of the CLI and then
   executed later with Mono.

Q: What kind of rules make the Common Intermediate Language useful for
   JITers?

A: The main rule is that the stack in the CLI is not a general purpose
   stack.   You are not allowed to use it for other purposes than
   computing values and passing arguments to functions or return
   values.  

   At any given call or return instruction, the types on the stack
   have to be the same independently of the flow of execution of your
   code. 

Q: Is it true that the CIL is ideal for JITing and not efficient for
   interpreters?

A: The CIL is better suited to be JITed than JVM byte codes, but you
   can interpret them as trivially as you can interpret JVM byte
   codes. 


** Mono and Java
   
Q: Why don't you use Java?  After all, there are many languages that
   target the Java VM.

A: You can get very good tools for doing Java development on free
   systems right now.  <a href="http://www.redhat.com">Red Hat</a> has
   contributed a <a href="http://gcc.gnu.org">GCC</a> <a
   href="http://gcc.gnu.org/java">frontend for Java</a> that can take
   Java sources or Java byte codes and generate native executables; <a
   href="http://www.transvirtual.com">Transvirtual</a> has implemented
   <a href="http://www.kaffe.org">Kaffe</a> a JIT engine for Java;
   Intel also has a Java VM called <a
   href="http://www.intel.com/research/mrl/orp">ORP</a>.

   The JVM is not designed to be a general purpose virtual machine.
   The Common Intermediate Language (CIL), on the other hand, is
   designed to be a target for a
   wide variety of programming languages, and has a set of rules
   designed to be optimal for JITers.

Q: Could Java target the CLI?

A: Yes, Java could target the CLI.  We have details on a <a
   href="ideas.html#guavac">project</a> that someone could take on to
   make this happen.

** Extending Mono

Q: Would you allow other classes other than those in the
   specification?

A: Yes.  The Microsoft class collection is very big, but it is by no
   means complete.  It would be nice to have a port of `Camel' (the
   Mail API used by Evolution inspired by Java Mail) for Mono
   applications.  

   You might also want to look into implementing CORBA for Mono.  Not
   only because it would be useful, but because it sounds like a fun
   thing to do, given the fact that the CLI is such a type rich
   system. 

   For more information on extending Mono, see our <a
   href="ideas.html">ideas</a> page.

** Mono and portability

Q: Will Mono only work on Linux?

A: Currently, we are doing our work on Linux-based systems and
   Windows.  We do not expect many Linux-isms in the code, so it
   should be easy to port Mono to other UNIX variants.   

Q: What about Mono on non X-based systems?

A: Our main intention at Ximian is to be able to develop GNOME
   applications with Mono, but if you are interested in providing a
   port of the Winform classes to other platforms (frame buffer or
   MacOS X for example), we would gladly integrate them, as long
   they are under a Free Software License. 

Q: Will Mono run on Windows?

A: We hope so.  Currently some parts of Mono only run on Windows
   (the C# compiler is a .NET executable) and other parts have only
   been compiled on Linux, but work on Windows with Cygwin.

Q: Will Mono depend on GNOME?

A: It will depend only if you are using a particular assembly (for
   example, for doing GUI applications).  If you are just interested
   in Mono for implementing a `Hello World Enterprise P2P Web
   Service', you will not need any GNOME components.

** Reusing existing Code

Q: What projects will you reuse or build upon?

A: We want to get Mono in the hands of programmers soon.  We are
   interested in reusing existing open source software.

Q: What about Intel's research JIT framework, ORP?

A: At this time, we are investigating whether we can use elements of
   ORP for Mono.   ORP is a research JIT engine that has a clear
   defined API that splits the JIT from the GC system and the actual
   byte code implementation.   It is a research product.

Q: What about using GNU Lightning?

A: We are also researching <a
   href="http://www.gnu.org/software/lightning/lightning.html">GNU
   Lightning</a>.

** Ximian and Microsoft

Q: Is Microsoft helping Ximian with this project?

A: Not exactly.  Ximian CTO Miguel de Icaza had a friendly
   conversation with Microsoft software architect David Stutz, but
   that's about the extent of the contact.
   Microsoft is interested in other implementations of .NET and are
   willing to help make the ECMA spec more accurate for this purpose.

   Ximian representatives have also spoken with Sam Ruby at the ECMA
   TG3 committee to discuss the same issues.

Q: Is Microsoft paying Ximian to do this?

A: No.

Q: Do you fear that Microsoft will change the spec and render Mono
   useless?

A: No.  Microsoft proved with the CLI and the C# language that it was
   possible to create a powerful foundation for many languages to
   interoperate.  We will always have that.  

   Even if changes happened in the platform which were undocumented,
   the existing platform would a value on its own.

   The benefits that you can get from the CLI are going to be
   there with or without `embracing and extending'.  We might not be
   able to run every .NET Windows application on Mono, but then again,
   it was already easy for someone to just use PInvoke to tie their
   application to Windows.

Q: Are Microsoft and Corel involved in the Mono implementation?

A: No, they are not.

Q: Are you writing Mono from the ECMA specs?

A: Yes, we are writing them from the ECMA specs and the published
   materials in print about .NET.

** Acronyms

Q: What is the difference between CLR (Common Language Runtime) and
   CLI (Common Language Infrastructure)?

A: CLI is the specification of an execution system.  The Microsoft
   implementation of this specification is named CLR. 

   Unless we come up with our own acronym, we could just call ours
   also CLR, just because it would do exactly the same thing the
   Microsoft implementation does.

<a name="gcc">
** Mono and GCC

Q: Are you working on a GCC front-end to C#?

A: We are seeking volunteers for this task. Visit the <a
   href="contributing.html">contributing</a> section if
   you'd like to work on this task.

Q: How about a GCC backend that will generate CIL images?

A: That would be great: it could provide a ton of free compilers that
   would generate CIL code.  This is something that people would want
   to look into anyway for Windows interoperation in the future.
   
   Visit the <a href="contributing.html">contributing</a> section if
   you'd like to work on this task.

Q: What about making a front-end to GCC that takes CIL images and
   generates native code?

A: I would love to see this, specially since GCC supports this same
   feature for Java Byte Codes.  You could use the metadata library
   from Mono to read the byte codes (ie, this would be your
   "front-end") and generate the trees that get passed to the
   optimizer.

   Ideally our implementation of the CLI will be available as a shared
   library that could be linked with your application as its runtime
   support. 
   
   Visit the <a href="contributing.html">contributing</a> section if
   you'd like to work on this task.

Q: But would this work around the GPL in the GCC compiler and allow
   people to work on non-free front-ends?

A: People can already do this by targeting the JVM byte codes (there
   are about 130 compilers for various languages that target the JVM).

Q: Why are you writing a JIT engine instead of a front-end to GCC?

A: The JIT engine and runtime engine will be able to execute CIL
   executables generated on Windows.

** Performance

Q: How fast will Mono be?

A: We can not predict the future, but a conservative estimate is that
   it would be at least `as fast as other JIT engines'.

   We would like to ship various JIT engines with Mono, just like
   Microsoft has done with their .NET development platform. We could
   provide a faster, JIT for fast load times but lower performance,
   and an and an optimizing JIT that would be slower at generating
   code but produce more optimal output.

   The CIL has some advantages over the Java byte code:  it is really
   an intermediate representation and there are a number of
   restrictions on how you can emit CIL code that simplify creating
   better JIT engines.

   For example, on the CIL the stack is not really an abstraction
   available for the code generator to use at will: it is just a way
   of creating a postfix representation of the parsed tree.  At any
   given call point or return point, the contents of the stack are
   expected to contain the same object types independently of how the
   instructions was reached.


** Licensing

Q: Will I be able to write proprietary applications that run with
   Mono?

A: Yes.  The licensing scheme is planned to allow proprietary
   developers to write applications with Mono.
   
Q: What license or licenses are you using for the Mono Project?

A: The C# Compiler is released under the terms of the GPL.  The class
   libraries will be under the LGPL or the GPL with a special
   exception.  The runtime libraries are under the LGPL.

   Since the LGPL is not suitable for embedded systems development, we
   are also licensing the libraries under the GPL with the following exception:

   If you link this library against your own program, then you do not
   need to release the source code for that program. However, any
   changes that you make to the library itself, or to any native
   methods upon which the library relies, must be re-distributed in
   accordance with the terms of the GPL.

   This is similar in spirit to <a
   href="http://www.gnu.org/software/classpath/classpath.html">GNU
   Classpath.</a>

Q: Can I subclass objects within the LGPL licensed Mono code and still release
   the resulting software under a closed license?

A: Yes.  Object Oriented Programming in the class library is a well
   understood interface barrier, and subclassing does not "count" as a
   modification, so you may develop proprietary applications with the
   Mono libraries.

Q: I would like to contribute code to Mono under a particular
   license. What licenses will you accept?

A: We will have to evaluate the licenses for compatibility first,
   but as a general rule, we will accept all GPL and LGPL-compatible
   licenses. If you want to use the BSD
   license, make sure you use the BSD license without the
   advertisement clause (The `Ousterhout License').

** Assorted questions

Q: You say that the CLI allows multiple languages to execute on the
   same environment.  Isn't this the purpose of CORBA?

A: The key difference between CORBA (and COM) and the CLI is that the
   CLI allows "data-level interoperability" because every
   language/component uses the same data layout and memory management.

   This means you can operate directly upon the datatypes that someone
   else provides, without having to go via their interfaces.  It also
   means you don't have to "marshall" (convert) parameters (data
   layouts are the same, so you can just pass components directly) and
   you don't have to worry about memory managment, because all
   languages/components share the same garbage collector and address
   space.  This means much less copying and no need for reference
   counting.

